# 逐笔数据转订单簿



金融市场上交易规则是这样的：想要买股票，一定要先委托，委托后才能成交或撤单。一定遵循**价格优先，时间优先**的原则

但是在不同的交易所里，数据的先后不一定，具体情况如下所述。



订单簿记录多档待要交易的数据，也就是未交易的数据，因此订单簿要在每笔订单进来的时候，根据委托数据进行增补，根据成交数据进行删减。

订单簿中，买方价格挂同价格序列的最高价（为了能快速交易）；同样地，卖方价格挂最低价。订单簿会根据每新进一笔订单都进行更新。



## 深交所逐笔数据转订单簿

> 深交所数据，具有**委托数据一定会比成交数据**先来的特点，有两类数据**order委托数据**和**trade成交数据**，委托数据一定是未完成待交易的数据，而成交数据一定是已交易完的数据。
>
> *深交所数据处理tips: 可用单号进行该笔数据的识别，因为委托一定会先于成交存在*，而上交就不同，详见<u>上交所逐笔数据转订单簿</u>
>
> **order数据处理逻辑**，数据分为3类：
>
> **限价单**：不必多说，在订单簿上已存在的价格序列后加qty；或不存在该价格，则新加该条数据；
>
> **本方最优**：特殊的市价单，价格同本方买一价或本方卖一价，qty增加；
>
> **市价单**：为了能最快速交易，直接挂对手方的买一价或卖一家，qty增加。
>
> 在处理本方最优和市价单时，如果该价格序列为空，那么说明此时处于涨停或跌停的价位上，因此无人买或卖，那么记录下该单号，以便在处理trade数据时，碰到该单号，直接跳过（因为这种涨停跌停的数据在委托数据上，而当前委托数据上无可挂靠的价格，因此它没记录在订单簿上，后面trade会出现该单号的原因是可能有人在撤销）
>
> **trade数据处理逻辑**，数据分为2类：
>
> **撤销**：根据单号识别在订单簿中哪里，进行删除（单方行为）
>
> **成交**：一笔成交一定得买卖双方都参与，才能成功完成，因此一笔成交会影响买卖双方（双方行为）
>
> 处理 trade 数据时，一定要考虑qty=0或num为空的时候，要从订单簿中删掉

```python
import numpy as np
import pandas as pd
from tqdm import tqdm


def gen_orderbook(code):
    df=read_data(code)
    order_book = {'bid': {'bid_price': [], 'bid_qty': [], 'bid_num': []},
                  'offer': {'offer_price': [], 'offer_qty': [], 'offer_num': []}}
    file_df = {}
    wrong_order_list=[]
    for t in tqdm(sorted(set(df['OrigTime']))):
        tmp_df=df[df.OrigTime==t]
        for _,r in tmp_df.iterrows():
            book_class = 'order' if str(r.ExecType) == 'nan' else 'trade'
            if book_class=='order': # 委托数据
                r.Side=int(r.Side)
                r.OrderType = str(r.OrderType)
                label = 'bid' if r.Side == 1 else 'offer'  # 判断买卖方向
                if r.OrderType=='2':
                    # 限价单处理逻辑
                    if r.Price not in order_book[label][f'{label}_price']:
                        # 当前订单簿无此价格，append进去
                        order_book[label][f'{label}_price'].append(r.Price)
                        order_book[label][f'{label}_qty'].append([r.OrderQty])
                        order_book[label][f'{label}_num'].append([r.ApplSeqNum])
                    else:
                        # 当前订单簿有此价格，把单号和qty加进去
                        idx=order_book[label][f'{label}_price'].index(r.Price)
                        order_book[label][f'{label}_qty'][idx].append(r.OrderQty)
                        order_book[label][f'{label}_num'][idx].append(r.ApplSeqNum)
                elif r.OrderType=='1': #市价单
                    oppo_label='bid' if label=='offer' else 'offer'
                    """以对手方卖一买一的价格作为price加进本方"""
                    if order_book[oppo_label][f'{oppo_label}_price']!=[]:
                        p=max(order_book[oppo_label][f'{oppo_label}_price']) if oppo_label=='bid' else min(order_book[oppo_label][f'{oppo_label}_price'])
                        order_book[label][f'{label}_price'].append(p)
                        order_book[label][f'{label}_qty'].append([r.OrderQty])
                        order_book[label][f'{label}_num'].append([r.ApplSeqNum])
                    else:
                        wrong_order_list.append(r.ApplSeqNum)

                elif r.OrderType=='U': #本方最优
                    if order_book[label][f'{label}_price']!=[]:
                        p=max(order_book[label][f'{label}_price']) if label=='bid' else min(order_book[label][f'{label}_price'])
                        idx=order_book[label][f'{label}_price'].index(p)
                        order_book[label][f'{label}_qty'][idx].append(r.OrderQty)
                        order_book[label][f'{label}_num'][idx].append(r.ApplSeqNum)
                    else:
                        wrong_order_list.append(r.ApplSeqNum)
            elif book_class=='trade': # 成交数据
                if (r.BidApplSeqNum in wrong_order_list) or (r.OfferApplSeqNum in wrong_order_list):
                    continue
                r.ExecType=str(r.ExecType)
                label='bid' if r.BidApplSeqNum>r.OfferApplSeqNum else 'offer' #撤单必有一个单号是0，成交也是单号比大小
                if r.ExecType=='4': # 撤销
                    bookno = r.BidApplSeqNum if label == 'bid' else r.OfferApplSeqNum
                    """
                    先找到待删除applseqnum在哪一对应的seq_num序列里面，找到该序列的index,再找到该applseqnum在序列里的index,
                    用这两个index确定位置，进行删除;
                    """
                    delidx=[x for x in order_book[label][f'{label}_num'] if bookno in x][0]
                    #选出待要删除的price对应的applseqnum序列了
                    idx=order_book[label][f'{label}_num'].index(delidx) # 返回该applseqnum序列的index
                    no_idx=order_book[label][f'{label}_num'][idx].index(bookno)
                    del order_book[label][f'{label}_num'][idx][no_idx]
                    del order_book[label][f'{label}_qty'][idx][no_idx]
                    if order_book[label][f'{label}_qty'][idx]==[]:
                        del order_book[label][f'{label}_price'][idx]
                        del order_book[label][f'{label}_qty'][idx]
                        del order_book[label][f'{label}_num'][idx]
                elif r.ExecType=='F': # 成交
                    bidno,offerno=r.BidApplSeqNum,r.OfferApplSeqNum
                    qty=r.TradeQty
                    for label, labelno in zip(['bid', 'offer'], [bidno, offerno]):
                        label_ = [x for x in order_book[label][f'{label}_num'] if labelno in x][0]# 找到目标序列
                        label_index = order_book[label][f'{label}_num'].index(label_)  # 找到目标序列的index
                        label_num_idx = order_book[label][f'{label}_num'][label_index].index(labelno)  # 找目标在目标序列中的idx
                        order_book[label][f'{label}_qty'][label_index][label_num_idx] -= min(
                            order_book[label][f'{label}_qty'][label_index][label_num_idx], qty)
                        # 减去 min(目标index的对应的qty,这笔要成交的qty)
                        if np.isclose(order_book[label][f'{label}_qty'][label_index][label_num_idx],0):
                            # 如果qty接近0，那么要删掉这个qty
                            del order_book[label][f'{label}_qty'][label_index][label_num_idx]
                            del order_book[label][f'{label}_num'][label_index][label_num_idx]
                        if len(order_book[label][f'{label}_num'][label_index])==0:
                            del order_book[label][f'{label}_num'][label_index]
                            del order_book[label][f'{label}_qty'][label_index]
                            del order_book[label][f'{label}_price'][label_index]

        # if t == 20250627093000990:
        order_book=sort_dict(order_book,'bid')
        order_book=sort_dict(order_book,'offer')
        # =======================================================
        # 数据生成文件
        new_row = {}
        new_row['OrigTime'] = t
        new_row['SecurityID'] = '000001'
        # 填充买价和买量 (BidPX1-BidPX20, BidSize1-BidSize20)
        for i in range(1, 21):
            if i <= len(order_book['bid']['bid_price']):
                new_row[f'BidPX{i}'] = order_book['bid']['bid_price'][i - 1]
                # 取每个价位的第一档数量
                new_row[f'BidSize{i}'] = sum(order_book['bid']['bid_qty'][i - 1]) if order_book['bid']['bid_qty'][
                    i - 1] else 0
                new_row[f'BidNum{i}']=len(order_book['bid']['bid_num'][i - 1])
            else:
                new_row[f'BidPX{i}'] = 0
                new_row[f'BidSize{i}'] = 0
                new_row[f'BidNum{i}'] = 0
        # 填充卖价和卖量 (OfferPX1-OfferPX20, OfferSize1-OfferSize20)
        for i in range(1, 21):
            if i <= len(order_book['offer']['offer_price']):
                new_row[f'OfferPX{i}'] = order_book['offer']['offer_price'][i - 1]
                # 取每个价位的第一档数量
                new_row[f'OfferSize{i}'] = sum(order_book['offer']['offer_qty'][i - 1]) if \
                order_book['offer']['offer_qty'][i - 1] else 0
                new_row[f'OfferNum{i}'] = len(order_book['offer']['offer_num'][i - 1])
            else:
                new_row[f'OfferPX{i}'] = 0
                new_row[f'OfferSize{i}'] = 0
                new_row[f'OfferNum{i}'] = 0
        file_df[t] = new_row
        # file_df.loc[len(file_df)] = new_row
        # print('OrigTime=', t)
        # print('bid:', order_book['bid']['bid_price'][0], ' ', sum(order_book['bid']['bid_qty'][0]))
        # print('offer:', order_book['offer']['offer_price'][0], ' ', sum(order_book['offer']['offer_qty'][0]))
    file_df = pd.DataFrame(file_df).T.reset_index(drop=True)
    file_df.to_feather(r'C:\Users\Administrator\Desktop\order_book_000001.feather')

def read_data(path_code,p='C:/Users/Administrator/Desktop/临时用/临时用/'):
    tmp_trade=pd.read_feather(p+'hq_trade_spot/'+path_code)
    tmp_order=pd.read_feather(p+'hq_order_spot/'+path_code)
    tmp_order_ = tmp_order[['ApplSeqNum', 'Price', 'OrderQty', 'Side', 'OrderType', 'OrigTime']]
    tmp_trade_ = tmp_trade[['ApplSeqNum', 'Price', 'TradeQty', 'ExecType', 'BidApplSeqNum', 'OfferApplSeqNum', 'OrigTime']]
    temp = pd.concat([tmp_order_, tmp_trade_]).sort_values(by=['ApplSeqNum']).reset_index(drop=True)
    return temp

def sort_dict(order_book,label):
    if len(order_book[label][f'{label}_price'])>1:
        # 对订单簿按照价格排序
        sort_index=sorted(range(len(order_book[label][f'{label}_price'])), key=lambda i: order_book[label][f'{label}_price'][i], reverse=label=='bid')
        # 买盘以高价优先,为了能够快速交易
        for k in list(order_book[label].keys()):
            order_book[label][k]=[order_book[label][k][i] for i in sort_index]
    return order_book

if __name__=='__main__':
    gen_orderbook('000001.feather')
```





## 上交所逐笔数据订单簿

> 上交所数据，具有**价格仅有限价单**，且**委托数据未必比成交数据先来**的特点，因此拿单号识别订单簿的交易代码可能会报错。
>
> 上交所中，委托数据和成交数据跟深交所中不同，同一订单号中的成交数据一直加到同笔数据中的A(同一个订单号仅有一个A)，才是深交所中的一笔委托数据。所以上交所中的委托数据，可能是多比成交完之后的剩余数据。**上交所里面的，成交数据相当于是已经被交易的数据，那它是在哪进行交易的呢，就得看它的对手方，代码逻辑就得寻找它的对手单号，实际上是它的对手单号，也就是它的这笔交易，已经且肯定在前面被委托过了。所以实际上，上交所是把深交所里面同一笔order(同一行)拆分成了好多笔，上交所合起来才是深交所的order，上交s的trade和撤销跟深交所一样了就，这三笔数据合一起，就可以走上面深交所转订单簿的代码了**！！
>
> **委托数据A**：处理方式同深交所限价单相同；
>
> **撤销数据D**：撤销可以根据单号去识别订单簿中的数据，进行删减，因为在上交所中，撤销单号一定在该笔单号的委托之后，而且一定存在；
>
> **成交数据T**：用对手方单号，仅在对手方上删减。

```python
import numpy as np
import pandas as pd
from dask.order import order
from tqdm import tqdm


def gen_orderbook():
    file_df = {}
    df=pd.read_feather(r'C:\Users\Administrator\Desktop\临时用\临时用\stock_tick\600000.feather')
    df=df[df.Type!='S']
    df.sort_values('TickIndex',inplace=True)
    # df['OrigTime']=df.TickTime.astype(str).str[:14] #.astype(int)
    df['OrigTime']=df.TickTime #.astype(int)
    order_book = {'bid': {'bid_price': [], 'bid_qty': [], 'bid_num': []},
                  'offer': {'offer_price': [], 'offer_qty': [], 'offer_num': []}}
    for t in sorted(set(df['OrigTime'])):
        tmp_df=df[df.OrigTime==t]
        for _,r in tmp_df.iterrows():
            bookno = max(r.BuyOrderNo, r.SellOrderNo)
            label = 'bid' if r.BuyOrderNo > r.SellOrderNo else 'offer'
            if r.Type=='A': # 委托数据
                # 限价单处理逻辑
                if r.Price not in order_book[label][f'{label}_price']:
                    # 当前订单簿无此价格，append进去
                    order_book[label][f'{label}_price'].append(r.Price)
                    order_book[label][f'{label}_qty'].append([r.Qty])
                    order_book[label][f'{label}_num'].append([bookno])
                else:
                    # 当前订单簿有此价格，把单号和qty加进去
                    idx=order_book[label][f'{label}_price'].index(r.Price)
                    order_book[label][f'{label}_qty'][idx].append(r.Qty)
                    order_book[label][f'{label}_num'][idx].append(bookno)
             #撤单必有一个单号是0，成交也是单号比大小
            elif r.Type=='D': # 撤销
                delidx = [x for x in order_book[label][f'{label}_num'] if bookno in x][0]
                # 选出待要删除的price对应的applseqnum序列了
                idx = order_book[label][f'{label}_num'].index(delidx)  # 返回该applseqnum序列的index
                no_idx = order_book[label][f'{label}_num'][idx].index(bookno)
                del order_book[label][f'{label}_num'][idx][no_idx]
                del order_book[label][f'{label}_qty'][idx][no_idx]
                if order_book[label][f'{label}_qty'][idx] == []:
                    del order_book[label][f'{label}_price'][idx]
                    del order_book[label][f'{label}_qty'][idx]
                    del order_book[label][f'{label}_num'][idx]

            elif r.Type=='T': # 成交
                if r.TickBSFlag=='N':
                    bidno, offerno=r.BuyOrderNo ,r.SellOrderNo
                    for label, labelno in zip(['bid', 'offer'], [bidno, offerno]):
                        label_ = [x for x in order_book[label][f'{label}_num'] if labelno in x][0]# 找到目标序列
                        label_index = order_book[label][f'{label}_num'].index(label_)  # 找到目标序列的index
                        label_num_idx = order_book[label][f'{label}_num'][label_index].index(labelno)  # 找目标在目标序列中的idx
                        order_book[label][f'{label}_qty'][label_index][label_num_idx] -= min(
                            order_book[label][f'{label}_qty'][label_index][label_num_idx], r.Qty)
                        # 减去 min(目标index的对应的qty,这笔要成交的qty)
                        if np.isclose(order_book[label][f'{label}_qty'][label_index][label_num_idx],0):
                            # 如果qty接近0，那么要删掉这个qty
                            del order_book[label][f'{label}_qty'][label_index][label_num_idx]
                            del order_book[label][f'{label}_num'][label_index][label_num_idx]
                        if len(order_book[label][f'{label}_num'][label_index])==0:
                            del order_book[label][f'{label}_num'][label_index]
                            del order_book[label][f'{label}_qty'][label_index]
                            del order_book[label][f'{label}_price'][label_index]
                else: #B/S
                    oppo_label='bid' if label=='offer' else 'offer'
                    labelno=min(r.BuyOrderNo,r.SellOrderNo)
                    label_=[x for x in order_book[oppo_label][f'{oppo_label}_num'] if labelno in x][0]
                    label_index=order_book[oppo_label][f'{oppo_label}_num'].index(label_)
                    label_num_idx=order_book[oppo_label][f'{oppo_label}_num'][label_index].index(labelno)
                    order_book[oppo_label][f'{oppo_label}_qty'][label_index][label_num_idx] -= min(
                        order_book[oppo_label][f'{oppo_label}_qty'][label_index][label_num_idx],r.Qty)
                    # 减去 min(目标index的对应的qty,这笔要成交的qty)
                    if np.isclose(order_book[oppo_label][f'{oppo_label}_qty'][label_index][label_num_idx],0):
                        del order_book[oppo_label][f'{oppo_label}_qty'][label_index][label_num_idx]
                        del order_book[oppo_label][f'{oppo_label}_num'][label_index][label_num_idx]
                    if len(order_book[oppo_label][f'{oppo_label}_num'][label_index]) == 0:
                        del order_book[oppo_label][f'{oppo_label}_num'][label_index]
                        del order_book[oppo_label][f'{oppo_label}_qty'][label_index]
                        del order_book[oppo_label][f'{oppo_label}_price'][label_index]
            # if t == 20250627093000990:
        order_book=sort_dict(order_book,'bid')
        order_book=sort_dict(order_book,'offer')
        # print('OrigTime=', t)
        # try:
        #     print('bid:', order_book['bid']['bid_price'][0], ' ', sum(order_book['bid']['bid_qty'][0]))
        #     print('offer:', order_book['offer']['offer_price'][0], ' ', sum(order_book['offer']['offer_qty'][0]))
        # except:
        #     pass
        # =======================================================
        # 数据生成文件
        new_row = {}
        new_row['OrigTime'] = t
        new_row['SecurityID'] = '000001'
        # 填充买价和买量 (BidPX1-BidPX20, BidSize1-BidSize20)
        for i in range(1, 21):
            if i <= len(order_book['bid']['bid_price']):
                new_row[f'BidPX{i}'] = order_book['bid']['bid_price'][i - 1]
                # 取每个价位的第一档数量
                new_row[f'BidSize{i}'] = sum(order_book['bid']['bid_qty'][i - 1]) if order_book['bid']['bid_qty'][
                    i - 1] else 0
                new_row[f'BidNum{i}'] = len(order_book['bid']['bid_num'][i - 1])
            else:
                new_row[f'BidPX{i}'] = 0
                new_row[f'BidSize{i}'] = 0
                new_row[f'BidNum{i}'] = 0
        # 填充卖价和卖量 (OfferPX1-OfferPX20, OfferSize1-OfferSize20)
        for i in range(1, 21):
            if i <= len(order_book['offer']['offer_price']):
                new_row[f'OfferPX{i}'] = order_book['offer']['offer_price'][i - 1]
                # 取每个价位的第一档数量
                new_row[f'OfferSize{i}'] = sum(order_book['offer']['offer_qty'][i - 1]) if \
                    order_book['offer']['offer_qty'][i - 1] else 0
                new_row[f'OfferNum{i}'] = len(order_book['offer']['offer_num'][i - 1])
            else:
                new_row[f'OfferPX{i}'] = 0
                new_row[f'OfferSize{i}'] = 0
                new_row[f'OfferNum{i}'] = 0
        file_df[t] = new_row
    file_df = pd.DataFrame(file_df).T.reset_index(drop=True)
    file_df.to_feather(r'C:\Users\Administrator\Desktop\order_book_600000.feather')

def sort_dict(order_book,label):
    if len(order_book[label][f'{label}_price'])>1:
        # 对订单簿按照价格排序
        sort_index=sorted(range(len(order_book[label][f'{label}_price'])), key=lambda i: order_book[label][f'{label}_price'][i], reverse=label=='bid')
        # 买盘以高价优先,为了能够快速交易
        for k in list(order_book[label].keys()):
            order_book[label][k]=[order_book[label][k][i] for i in sort_index]
    return order_book

if __name__=='__main__':
    gen_orderbook()
```

