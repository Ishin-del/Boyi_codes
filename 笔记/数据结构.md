# 									数据结构



## 数据结构

> 数据结构包括：线性结构和非线性结构

### **线性结构**

（1) 数据元素之间 -> 一对一的线性关系

  (2) 两种存储结构：

​	a. 顺序存储 

> 顺序表中的存储元素是连续的，这样存储的线性表称为顺序表。

​		这个连续指的是说，在内存分配中，地址是连续的。连续说的是地址。比如：数组。

​	b. 链式存储

> 链表中的存储元素不一定是连续的，这样存储的线性表称为链表，节点中存放数据元素以及相邻元素的地址信息。

​		这种存储结构比较好的一点就是，它可以充分利用碎片内存。比如：链表。

 （3）线性结构常见的有：数组，队列，链表和栈。

### **非线性结构**

这种结构，元素之间的对应关系至少不是一对一了...

> 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构



## 数组

### 数组 array

```java
/*
数组：在程序中存储同一种数据类型，多个元素的固定容器

数组的特点：
	1.数组一旦初始化，其长度是不可改变的
	2.在内存中数组所有的元素必须是同一数据类型
	3.在程序中声明初始化的数组。至少含有两个元素数据
	（补充：可以声明初始化存储0个元素和1个元素（直接int就行）的数组，但没意义）

数组的声明：
	格式1：数据类型[] 数组名；
			举例：int[] arr
	格式2：数据类型 数组名[]；
			举例：int arr[]

数组的初始化：
	动态初始化：只初始化数组的长度（大小），不初始化具体元素，jvm可以直接获取到长度
		格式：数据类型 数组名=new 数据类型[数组长度]
	静态初始化：不初始化数组长度，只初始化元素，jvm间接获取数据长度
		格式1：数据类型 数组名=new 数据类型[]{元素1，元素2，...}
		格式2：数据类型 数组名={元素1，元素2，...}
			备注：JVM会通过数组名前面的数据类型给内存中申请并开发空间，由jvm隐式提供new；如果JVM不能获取数组名前面的数据类型，那么不能隐式提供new

数组声明初始化的注意事项：
	1.在程序中不可以使用动静结合的方式
	2.在程序中，数组元素支持类型转换，需要保证在内存中元素必须同一类型
	3.静态初始化的简化版不可以先声明后初始化 *** （动态可以，但前后的数组名字不代表同一个）
	4.在程序中，数组的索引值从0开始到长度-1，长度为0没有索引值
	5.在程序中，获取数组中的元素，如果索引值过大或者非法（负值），导致ArrayIndexOut...(数组索引越界异常)
	6.在程序中，如果通过null获取数组元素或者通过null访问对象元素，导致NullPointer(空指针异常)
	7.数组一旦初始化，其长度是不可改变的，针对数组进行重新赋值，原来的数组并没有改变，改变的是数组的引用
	    举例：int[] arr=new int[3]; arr=new int[5];

数组的应用：
    基础应用：针对数组中的元素不做索引位置上的调整，只做元素的获取应用
        例如：数组的元素拼接，求和，求最值，...
    高级应用：针对数组中元素的索引位置进行调整，获取到所需的数组
        例如：数组的反转，排序，...
    综合应用：数组和方法的综合应用
        例如：数组的动态扩容，插入，删除，...
*/
//数组的声明：
public class Class05{
    public static void main(String[] args){
        //动态初始化
        int[] arr01=new int[3];
        int arr02[]=new int[3];
        //静态初始化
        int[] arr03=new int[]{4,6,2};
        //简易版静态
        int[] arr04={7,2,5};

        System.out.println(arr01);  //这个是地址值（人工模拟的，跟真实地址值不同，真实地址值是物理地址），[I@1b6d3586
        System.out.println(arr02[2]); //默认值是0
        System.out.println(arr03[2]);//索引为2对应的元素为最后一个,2
        System.out.println(arr04[2]);//5

        System.out.println("=================================");

        //动态初始化和静态初始化可以先声明，再赋值：
        int[] arr05;
        //静态
        arr05=new int[]{9,2,3};
        //动态
        arr05=new int[3];
        System.out.println(arr05[1]);
        //下面不可以，会报错，简易版不可以
        //arr05 = {1,2,3};
        //int arr05=new int[3]{2,5,6}  不可以动静结合
    }
}
//获取数组的元素：
//	需要通过数组的索引值（索引组：JVM对数组中元素的动态编号，编号从0开始，到长度-1结束，长度为0的没有索引值）数组名[索引值]


//数组的应用：数组拼接
/*public class Class05 {
    public static void main(String[] args){
        //先声明一个数组
        int[] arr = new int[]{1,6,7};
        System.out.print("数组是：[");
        //开始遍历：
        for (int i=0;i<arr.length;i++){
            if (i==arr.length-1){
                System.out.print(arr[i]+"]");
            }else{
            System.out.print(arr[i]+",");
            }

        }
    }
}*/

"================================================================================"


//数组求和
public class Class06{
    public static void main(String[] args) {
        int[] arr={3,7,9,1,0,2};
        System.out.println(sum(arr));
    }
    public static int sum(int[] arr){
        int sum=0;
        for (int i = 0; i < arr.length; i++) {
            sum +=arr[i];
        }
        return sum;
    }
}

//获取数组最大值
public class Class06{
    public static void main(String[] args) {
        int[] arr={5,15,2000,10000,100,4000};
        //临时最大值变量
        int max=arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (max<arr[i]) {
                max=arr[i];
            }
        }
        System.out.println(max);
    }
}

//评委打分：去掉一个最高分和最低分，求平均分
public class Class06{
    public static void main(String[] args) {
        int[] arr={87,65,76,79,80,90};
        int max=arr[0];
        int min=arr[0];
        int[] newarr=new int[arr.length-2];
        int sum=arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (max < arr[i]) {
                max = arr[i];
            }
            if(min>arr[i]){
                min=arr[i];
            }
            sum+=arr[i];
        }
        double avg=(sum-max-min)*1.0/(arr.length-2);
        System.out.println(avg);

//            if(arr[i]==max||arr[i]==min){
//                continue;
//            }
//            newarr=new int[] {arr[i]};
//        }

//        System.out.println(sum);
//        System.out.println(sum/(arr.length-2));//平均数
    }
}


//数组反转

public class Class06 {
    public static void main(String[] args){
        //way1
        int[] arr= new int[] {13,2,5,7,4,6};
        int[] arr2 = new int[6];
        for (int i = 0; i < arr.length; i++) {
           // int[] arr2 = new int[6];
            arr2[i]=arr[arr.length-1-i];
        }
        for (int i = 0; i < arr2.length; i++) {
            System.out.println(arr2[i]);
        }
        System.out.println("==================================");
        //way2
        int [] ar={3,5,8,7,9};
        for (int s = 0,e=ar.length-1 ; s<= e; s++,e--) {
            int tem=ar[s];
            ar[s]=ar[e];
            ar[e]=tem;
        }
        for (int i = 0; i < ar.length; i++) {  //黄色是提醒
            System.out.println(ar[i]);
        }
    }
}*/
    
//数组的动态操作：扩容,删除,插入

public class Class06 {
    public static void main(String[] args) {
        int[] arr01 = {2, 7, 3, 8, 9};
        int[] an01= insert(arr01, 2, 0);  // 泛黄什么意思？
        System.out.println(an01[2]);
        printme(an01);
        System.out.println("=======================================");
        int[] arr02 = {5,3,8,2,1};
        printme(arr02);  //an02
        System.out.println("=======================================");
        int[] arr03 = {4,7,2,6,1};
        int[] an03= delete(arr03, 2);
        printme(an03);
        System.out.println("=======================================");
        int[] arr04={1,4,2};
        int[] an04=addon(arr04,9);
        printme(an04);

    }
    /////////////////////////////////////
    //插入
    public static int[] insert(int[] arr, int index, int num) {
        if (arr == null) {
            System.out.println("数组为空");     //健壮性判断
            return arr;
        }

        if (index < 0 || index > arr.length-1) {    //Q:这里可不可以用else if替换?  A:不可以
            System.out.println("数据有误");    //健壮性判断
        }

        if (arr.length == 0) {
            int[] newarr = {num};
            return newarr;
        }

        int[] newArr = new int[arr.length + 1];
        for (int i = 0; i < arr.length; i++) {
            if (i < index) {
                newArr[i] = arr[i];
            } else {
                newArr[i + 1] = arr[i];
            }
        }
        return newArr;
    }
    //打印
    ///////////////////////////////////////////////
    public static void printme(int[] arr) {
        if (arr == null) {
            System.out.println("数组为空");
            return;
        }
        if (arr.length == 0) {
            System.out.println("[]");
            return;
        }
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            if (i == arr.length-1) {
                System.out.println(arr[i] + "]");
            } else {
                System.out.print(arr[i] + ",");
            }
        }
    }
   /////////////////////////////////////////////////
    //删除
    public static int[] delete(int[] arr, int index) {
        if (arr == null) {
            System.out.println("数组为空");
            return arr;
        }    //判断为空

        if (index<0||index>arr.length-1){
            System.out.print("数据有误");
            return arr;
        }

        if (arr.length == 0) {
            System.out.println("[]");
        }

        //System.out.print("[");
        int[] newarr=new int[arr.length-1];
        for (int i = 0; i < arr.length; i++) {
            if (i == index) {
                continue;
            }
            if (i<index){
                newarr[i] = arr[i];
            }
            if(i>index){
                newarr[i-1] = arr[i];
            }
        }
        return newarr;
    }
    ///////////////////////////////////////////
    //扩容
    public static int[] addon(int[] arr, int num) {
        if (arr == null) {
            System.out.println("数组为空");
            return arr;
        }    //判断为空

        if (arr.length == 0) {
            int[] newarr= new int[]{num};
            return newarr;
        }

        int[] newarr = new int[arr.length + 1];//index多加一位
        for (int i = 0; i < arr.length; i++) {
            newarr[i] = arr[i];
        }
        newarr[newarr.length - 1] = num;
        return newarr;
    }
}

"==========================================================="

/*二维数组:
      数组元素为一维数组的数组
  二维数组的声明：
      数据类型[][] 数组名；
      数据类型 数组名[][];
      数据类型[] 数组名[];
   二维数组的初始化：
        动态初始化：
            格式一：数据类型[][] 数组名=new 数据类型[x][y]；x:行，y:列；
            格式二：数据类型[][] 数组名=new 数据类型[x][]；
        静态初始化：
            格式一：数据类型[][] 数组名=new 数据类型[][]{new 数据类型[]{元素1，元素2，..},new 数据类型[]{元素1，元素2，..},...}；
            格式二：数据类型[][] 数组名=new 数据类型[][]{{元素1，元素2，..},{元素1，元素2，..},...}；
            格式二：数据类型[][] 数组名={{元素1，元素2，..},{元素1，元素2，..},...}；先声明后赋值不可以了
 */

public class Class06{
    public static void main(String[] args) {
        int[][] arr01=new int[3][4];//内存中含有4个数组（一个二维数组，3个一维数组） 推荐！
        int[][] arr02=new int[3][];//内存中含有1个数组（一个二维数组，三个一维数组没有初始化）
        //for (int i = 0; i < dataframe.length; i++) {
        //    System.out.println(dataframe);
        //}
        System.out.println(arr01[0]);
        System.out.println(arr01[0][0]);
        System.out.println("===================================");
        int[][] arr03=new int[][] {new int[]{11,22,33},new int[]{44,55},new int[]{66,77,88,99}};
        int[][] arr04=new int[][] {{11,22,33},{44,55},{66,77,88,99}};
        int[][] arr05={{11,22,33},{44,55},{66,77,88,99}};
        System.out.println(arr03[0][0]);
        System.out.println(arr03[1][0]);
        System.out.println("===================================");
        for (int i = 0; i < arr03.length; i++) {
            for (int i1 = 0; i1 < arr03[i].length; i1++) {
                System.out.println(arr03[i][i1]);
            }

        }
    }
}


/*
数组的排序：
分类：
    冒泡排序 --> 现阶段
    选择排序 --> 现阶段
    插入排序
    归并排序
    快速排序
    希尔排序
    ......
 */

"==============================================================="

//数组的冒泡排序
//原理：比较相邻两个元素，将值大的元素交换至右端
public class Class06{
    public static void main(String[] args) {
        int[] arr={6,3,8,2,9,1};
        //int[] temp=new int[6];
        for (int i = 0; i < arr.length-1; i++) {
            for(int j=0;j<arr.length-1;j++){
                if (arr[i]>arr[j]){
                    int e;
                    e=arr[j];
                    arr[j]=arr[i];
                    arr[i]=e;
                }
            }
        }
        for (int a=arr.length-1; a >0; a--) {
        System.out.print(arr[a]+" ");
        }
       System.out.println("========================");
        for (int count=1;count<arr.length;count++){ //外层循环：求几次最大值
            for (int i=0;i<arr.length-count;i++){   //内层循环：求一次最大值需要判读几次
                //int index=i;
                if (arr[i]>arr[i+1]){
                    int temp=arr[i];
                    arr[i]=arr[i+1];
                    arr[i+1]=temp;
                }
            }
        }
        for (int a=0; a<arr.length; a++) {
            System.out.print(arr[a] + " ");
        }
    }
}



//选择排序：每次从找最小的元素，放在第一位，依次类推
public class Class06{
    public static void main(String[] args) {
        int[] arr = {3, 9, 7, 2, 4, 6};
        for (int i = 0;i<arr.length-1;i++) {
            int index = i;  //记录临时最小值索引
            for (int j=i+1;j<arr.length;j++){  //遍历数组，获取最小值索引
                if  (arr[index] > arr[j]) {
                    index=j;
                }
            }
            if(index != i){
                int temp=arr[i];
                arr[i]=arr[index];
                arr[index]=temp;
            }
        }
        for (int a=0; a<arr.length; a++) {
            System.out.print(arr[a] + " ");
        }
    }

}

/*方法实参和形参的特点:
               当方法的形参是基本类型时:
                   1.参数传递的是数据值
                   2.形式参数数据值的改变不影响实际参数的数据值
               当方法的形参是引用类型时:
                   1.参数传递的是地址值
                   2.形式参数地址值的改变不影响实际参数的地址值
                   3.形式参数地址值不改变,地址值中内容的改变影响实际参数中的内容*/

public class Class06 {
    public static void main(String[] args) {
        //声明并初始化数组
        int[] arr = {11, 22, 33};

        System.out.println("arr1 = " + arr);

        method01(arr);

        System.out.println("arr4 = " + arr);

        System.out.println("======================================");

        System.out.println("arr1 = " + arr);
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        System.out.println(arr[2]);

        method02(arr);

        System.out.println("arr4 = " + arr);
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        System.out.println(arr[2]);
    }

    public static void method02(int[] arr) {
        System.out.println("arr2 = " + arr);
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        System.out.println(arr[2]);

        arr[0] = 100;
        arr[2] = 300;

        System.out.println("arr3 = " + arr);
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        System.out.println(arr[2]);
    }

    public static void method01(int[] arr) {
        System.out.println("arr2 = " + arr);

        //改变数组的地址值
        arr = new int[5];
        System.out.println("arr3 = " + arr);
    }
}


//练习：查找指定元素在数组中出现的第一次索引
public class Class06 {
    public static void main(String[] args) {
        int[] arr={2,5,8,3,1};
        System.out.println(getIndex(arr,3));
    }

    public static int getIndex(int[] arr,int num){
        int index=-1;
        for (int i = 0; i < arr.length; i++) {
            if (num==arr[i]){
                index=i;
            }
            if (arr==null){
                return index;
            }
        }
        return index;
    }
}

//数组的二分查找法,无健壮性！！！！！！
public class Class06{
    public static void main(String[] args) {
        //初始化
        int[] arr = {3, 5, 7, 8, 9};
        int num=9;
        //循环
        //int index=-1;
        int start = 0;
        int end = arr.length - 1;
        int mid = (start + end) / 2;
        while (start <= end) {
            if (num <arr[mid]) {
                end = mid - 1;
                mid = (start + end) / 2;
            } else if (num >arr[mid]) {
                start = mid + 1;
                mid = (start + end) / 2;
            } else {
                //index = mid;
                break;
            }
            //mid= (start + end) / 2;
        }
        System.out.println(mid);
    }
}

//可变参数
可变参数（JDK5.0），无法确认要存多少个参数的时候...，格式：数据类型... 可变参数名
可变参数本质上就是根据传递过来的参数进行静态初始化的数组
注意事项：
    1.如果形参列表包括可变参数和其他参数，可变参数声明到最后一位
    2.方法中最多一个可变参数
public class Class06{
    public static void main(String[] args) {
        int[] arr={2,7,4,2,5};
        System.out.println(sum(arr));
    }
    public static int sum(int[] arr){
        int sum=0;
        for (int i = 0; i <=arr.length-1; i++) {
            sum+=arr[i];
        }
        return sum;
    }


}
```

（ 自己查到的笔记 ）

> 用一组<u>连续的内存空间</u>来存储一组具有<u>相同类型的数据</u>。

数组可以随机访问；

但是，操作比较低效，比如删除和插入操作，为了保证连续性需要做大量的数据搬移工作。（ 就是说无论删除还是插入，都需要对当前位置后面部分所有的元素进行一次移位 ）

> 计算机会给每一个内存单元分配一个地址，计算机通过地址来访问内存中的数据。

**ArrayList**

> java 中的 ArrayList 相当与一个动态数组，支持扩容。它可以把很多数组操作的细节封装起来，比如数组的插入和删除。
>
> 数组在定义的时候，因为需要给它分配连续的内存空间，需要预先指定其大小，当存放的数据大于其大小的时候，我们需要从新分配一块更大的空间，把原来的复制过去在插入新的元素。
>
> ArrayList 中，当空间不够用的时候，它会自动扩容为原来的 1.5 倍的大小。
>
> 因为扩容设计到内存的申请和数据的搬移，这是比较耗时的，所以，如果事先能确定数据的大小，做好在创建 ArrayList 的时候指定其大小
>
> 虽然 ArrayList 比数组好用，不过有些时候使用数组会更好一些。
>
> 1）因为 ArrayList 无法存储基本类型，int，long 等需要封装成 Integer，Long类，而自动装箱和拆箱的操作也会有一定的性能消耗，所以如果关注性能或者想用基本类型就选用数组
>
> 2）如果数据的大小已经知道，并且对数据的操作简单，可以直接使用数组
>
> 3）当使用多为数组的时候，用数组表示起来更加直观比如 int [ ] [ ] arr；而用容器的话则需要这样定义 ArrayList arr。
>
> 在开发中，一般情况下直接使用 ArrayList 就可以，如果是偏底层的开发比如网络框架开发等需要更高的性能，使用数组更合适。

[数据结构之数组]: https://blog.csdn.net/mingyunxiaohai/article/details/85758347



### 稀疏数组 sparse array

这是个非线性结构...

#### 基础概念

> 当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
>
> 
>
> 稀疏数组的处理方法：
>
> 1. 记录数组一共几行几列，有多少个不同的值
> 2. 把具有不同值的元素的行列及值记录在一个小规模的数组中（也就是稀疏数组），缩小程序规模

<img src="C:\Users\TIAN Yixin\AppData\Roaming\Typora\typora-user-images\image-20220716183111224.png" alt="image-20220716183111224" style="zoom: 50%;" />

<img src="C:\Users\TIAN Yixin\AppData\Roaming\Typora\typora-user-images\image-20220716183133800.png" alt="image-20220716183133800" style="zoom: 50%;" />

如上图，下方（稀疏数组）就是上方（原二维数组）的稀疏数组。

稀疏数组的第0行记录原二维数组几行，几列，有几个值（6，7，8）。

下面每行记录原二维数组中非0数据的信息。

* 注意：这个 row 和 column 都是从 0 开始记。



#### 转换思路

二维数组转稀疏数组：

1. 遍历二维数组，得到有效数据的个数 sum；
2. 根据 sum 创建稀疏数组 sparseArr int [ sum+1 ] [3]；
3. 将二维数组的有效数据存入到稀疏数组。



稀疏数组转二维数组：

1. 读取稀疏数组的第一行，根据第一行的数据，创建对应二维数组；
2. 读取稀疏数组的后几行数据，并赋值给对应二维数组。





#### 代码实现

```java
package com.attyx.dsArray;

import java.io.*;
import java.util.ArrayList;

public class SparseArray {
    public static void main(String[] args) throws IOException {
        //1.先创建原始的二维数组 11*11
        //0：表示没有棋子；1：黑子；2；蓝子
        int chessArr1[][]=new int [11][11];
        chessArr1[1][2] =1 ;
        chessArr1[2][3] =2 ;

        //原二维数组创建完毕，下面输出一下：
        System.out.println("原始的二维数组：");
        /*for (int i = 0; i < chessArr1.length; i++) {
            for (int j = 0; j < chessArr1[0].length; j++) {
                System.out.print(chessArr1[i][j]+" ");
            }
            System.out.println();
        }*/
        for(int[] row: chessArr1){
            for(int data:row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
        //二维数组转稀疏数组：
        //1.先遍历二维数组 得到非0数据的个数
        int sum = 0;
        for (int i = 0; i < chessArr1.length; i++) {
            for (int j = 0; j < chessArr1[0].length; j++) {
                if(chessArr1[i][j]!=0){
                    sum +=1;
                }
            }
        }
        System.out.println("sum="+sum);

        //2.创建对应的稀疏数组
        int[][] sparseArr=new int [sum+1][3];
        //给稀疏数组赋值
        sparseArr[0]=new int[] {11,11,sum};

        //遍历二维数组，将非0值存放到稀疏数组中
        int count=0; //count用于记录是第几个非0数据
        for (int i = 0; i < chessArr1.length; i++) {
            for (int j = 0; j < chessArr1[0].length; j++) {
                if(chessArr1[i][j]!=0){
                    count++;
                    sparseArr[count][0]=i;
                    sparseArr[count][1]=j;
                    sparseArr[count][2]=chessArr1[i][j];
                }
            }
        }
        // 输出稀疏数组的形式
        System.out.println();
        System.out.println("得稀疏数组为下：");
        for (int i = 0; i < sparseArr.length; i++) {
            for (int j = 0; j < sparseArr[0].length; j++) {
                System.out.print(sparseArr[i][j]+" ");
            }
            System.out.println();
        }

        //将稀疏数组写出到磁盘
        //a.使用file对象创建流对象
        File file = new File("D:\\悉尼\\JavaProjectFiles\\sparseArr");
        FileWriter fw = new FileWriter(file);


        //b.写出数据
        for (int i = 0; i < sparseArr.length; i++) {
            for (int j = 0; j < sparseArr[0].length; j++) {
                fw.write(sparseArr[i][j]+" ");
            }
            fw.write("\n");
        }

        //c.关闭资源
        fw.close();

        System.out.println();
        System.out.println("================~华丽的分割线~================");
        System.out.println();

        //将稀疏数组从磁盘中读出来
        //a.创建流对象
        FileReader fr = new FileReader("D:\\悉尼\\JavaProjectFiles\\sparseArr");
        BufferedReader br = new BufferedReader(fr); //创建缓冲流对象
        ArrayList<String> list = new ArrayList<>(); //创建集合存入数据
        String line;    //line用来放一行数据
        while ((line = br.readLine())!=null){   //逐行读取fr文件中的内容
            list.add(line); //将读取到的数据放入集合中
        }
        int rows = list.size();  //几行
        String s = list.get(0); //获取第0行的值
        int col = s.split(" ").length; //几列

        //创建空数组用来返回稀疏数组
        int r=0;    //记录行数
        int[][] sparseArr1 = new int[rows][col];
        for (String str : list) {   //遍历集合
            //用“ ”进行分割，用字符串数组接收
            String[] strs = str.split(" ");
            for (int i = 0; i < col; i++) {
                sparseArr1[r][i]=Integer.valueOf(strs[i]);
            }
            r+=1;   //行数+1
        }
        br.close();
        fr.close();

        System.out.println("原始的稀疏数组：");
        for (int i = 0; i < sparseArr1.length; i++) {
            for (int j = 0; j < sparseArr1[0].length; j++) {
                System.out.print(sparseArr1[i][j]+" ");
            }
            System.out.println();
        }

        //将稀疏数组转化为二维数组：
        //1.读取稀疏数组的第一行，根据第一行的数据，创建对应二维数组；

        int chessArr2[][] = new int [sparseArr1[0][0]][sparseArr1[0][1]];

        //2.读取稀疏数组的后几行数据（从第二行开始），并赋值给对应二维数组。
        for (int i = 1; i < sparseArr1.length ; i++) {
            chessArr2[sparseArr1[i][0]][sparseArr1[i][1]]=sparseArr1[i][2];
        }

        System.out.println("恢复后的二维数组：");
        for(int[] row: chessArr2){
            for(int data:row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
    }
}

```



## 队列

线性结构

有序列表（先进先出），可以用**数组**或**链表**实现。数组：最基本的数据结构；链表：？？？

先进先出：取数据从队列的头部取，增数据从队列的尾部增

### 数组模拟队列

  Queue(类)：

​		成员变量：数组，maxsize(最大容量)，front（头部，随数据的输出改变），rear（尾部，随数据的输入改变）

​		成员方法：addQueue

#### 数组模拟队列代码实现

```java
package queue.array_queue;

import java.lang.reflect.Array;

//使用数组模拟队列：编写一个ArrayQueue类
public class ArrayQueue{
    //成员变量：数组,maxSize,front,rear
    private int maxSize;
    private int front; //头部，指向队列头的前一个位置
    private int rear;  //尾部，指向队列的最后一个数据
    private int[] arr;  //队列本身，存放数据

    //创建队列（构造器）
    public ArrayQueue(int arrMaxSize){
        maxSize=arrMaxSize;
        arr=new int[maxSize];
        front=-1;
        rear=-1;
    }

    //判读队列是否满
    public boolean isFull(){
        return rear == maxSize-1;
    }

    //判读队列是否为空
    public boolean isEmpty(){
        return front==rear;
    }

    //添加数据到队列
    public void addQueue(int num){
        //判断队列是否满
        if(isFull()){
            System.out.println("the queue is already full");
        }
        //rear后移
        rear++;
        arr[rear]=num;
    }


    //获取队列数据（出队列）
    public int getQueue(){
        //判断队列是否空
        if(isEmpty()){
            // 通过抛异常来处理 RuntimeException
            throw new RuntimeException("the queue is empty");
        }
        //front后移
        front++;
        return arr[front];
    }


    //显示队列的所有数据
    public void showQueue(){
        //如果为空无法遍历
        if(isEmpty()){
            System.out.println("the queue is empty");
            return;
        }
        //遍历数据
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }


    //显示队列的头部，头数据
    public int headQueue(){
        //判断为空，抛异常
        if(isEmpty()){
            throw new RuntimeException("the queue is empty");
        }
        //返回头数据
        return arr[front+1];
    }
}

//TODO:需要优化，此时数组只能用一次，无法形成环形队列

================================================================================================================

package queue.array_queue;

import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        //普通数组队列测试
        //ArrayQueue queue = new ArrayQueue(3);
        //环形队列的测试类
        CircleQueue queue = new CircleQueue(4);//因为多预留了一个位置,有效数据maxSize是3个

        Scanner sc = new Scanner(System.in);
        boolean loop=true;
        while(loop){
            System.out.println("a:add num to the queue");
            System.out.println("g:get num from the queue");
            System.out.println("s:show the queue");
            System.out.println("h:head of queue");
            System.out.println("e:exit the programming");
            System.out.println("enter a choice:");
            String choose=sc.next();

            switch (choose){
                case "a":
                    System.out.println("exter a number");
                    int i = sc.nextInt();
                    queue.addQueue(i);
                    break;
                case "g":
                    try {
                        int res = queue.getQueue();
                        System.out.printf("the number is getted is %d\n", res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "s":
                    try {
                        queue.showQueue();
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "h":
                    try {
                        int head = queue.headQueue();
                        System.out.printf("the head is %d\n", head);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "e":
                    loop=false;
                    break;
            }
        }
        System.out.println("the programming is stopped");
    }
}
```



#### 环形数组模式队列代码实现

使数组复用，模拟环形队列的思路分析：

​	1.front变量做调整：front指向队列的第一个元素。front的初始值=0。

​	2.rear变量做调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定。rear的初始值=0。

​	3.当队列满时（rearmaxSize-1），判断变为（rear+1）%maxSize==front

​	4.队列中有效的数据的个数: (rear + maxsize - front)%maxSize

```java
package queue.array_queue;


/*
* 取模：
* 如果：c=a/b
* 那模就是：a-(b*c)
* */
//优化后的环形队列，可以反复使用
public class CircleQueue {
    //成员变量
    private int maxSize;
    private int[] arr;
    private int front; //指向队列的第一个元素
    private int rear;  //指向队列的最后一个元素的后一个位置

    //构造器
    public CircleQueue(int arrMaxSize){
        maxSize=arrMaxSize;
        arr=new int[maxSize];
        //front=0;
        //rear=0;
    }

    //判断是否满
    public boolean isFull(){
        return front==(rear+1)%maxSize;
    }

    //判断是否空
    public boolean isEmpty(){
        return front==rear;
    }

    //addQueue
    public void addQueue(int num){
        if(isFull()){
            throw new RuntimeException("already full");
        }
        arr[rear]=num;
        rear=(rear+1)%maxSize;
    }

    //getQueue
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("is empty");
        }
        //先保存front对应的值
        int val=arr[front];
        //front后移
        front=(front+1)%maxSize;
        //返回临时变量
        return val;
    }


    private int size(){
        return (rear-front+maxSize)%maxSize;
    }
    //showQueue
    public void showQueue(){
        if (isEmpty()){
            throw new RuntimeException("is empty");
        }

        //从front开始遍历，遍历有效个数个元素
        for (int i = front; i < front+size(); i++) {
            System.out.printf("arr[%d]=%d\n",i%maxSize,arr[i%maxSize]);
        }
    }

    //headQueue
    public int headQueue(){
        if(isEmpty()){
            throw new RuntimeException("is empty");
        }
        return arr[front];
    }
}

```



## 链表

**1. Linked List (有序列表)**

> 有序集合：集合里的元素可以根据key或index访问；无序集合：集合里的元素只能遍历。
>
> 
>
> 注意：比如一个列表 [ 1,3,2 ]
>
> 排列成一个按**关键字**有序的序列。比如：index=0的位置是1，index=1是3，index=2是2，关键字是每个元素的位置，就是有序。
>
> 如果关键字是元素的大小，就是无序的。(这里的关键字，应当指的是下标index)



**2. 特点之一：链式存储**

> 也就是链表，就是说，存储的元素**不一定连续**；（内存结构）
>
> 
>
> 以节点的方式存储；
>
> 节点中存放数据元素（data域）以及相邻元素的地址信息（next域：指向下一个节点）。
>
> 
>
> 分为：带头节点的链表和没有头节点的链表。

分一分内存结构和逻辑结构：

> 逻辑结构是一个数据，它的next指向下一个数据（按照关键字顺序）。但内存结构上，在内存里，这种顺序并不连续。



### 单向链表

**添加**

不考虑顺序，直接加到后面

> 添加（创建）
>
>    1.头节点：不存放数据，用来表示单链表的头（head）
>
> 2. 后面每添加一个节点（节点也就是一个类class），直接加入到链表的最后遍历



> 遍历：
>
> 通过一个辅助（指针）遍历，帮助遍历整个链表



考虑编号顺序：

> 1.通过辅助指针（变量），先找新添加的节点位置。（遍历）
>
> 2.新的节点的 next域 = temp.next
>
> 3.让temp.next=新的节点

**修改**

**删除**

> 删除思路：
>
> 1.辅助变量，找到待删除节点的前一个节点temp
>
> 2.将temp.next=temp.next.next
>
> 3.被删除的节点将不会有其他引用指向，会被垃圾回收机制回收

```java
//这个是添加直接到尾部，不管顺序

package linked_list.single_linked_list;

//定义一个HeroNode,每一个HeroNode对象就是一个节点
public class HeroNode {
    public int no;
    public String name;
    public String nickname;
    public HeroNode next;//指向下一个节点

    //构造器
    public HeroNode(int no,String name,String nickname){
        this.no=no;
        this.name=name;
        this.nickname=nickname;
    }


    //为了显示方便，重写toString

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\''+
                '}';
    }
}

//=================================================================================================================

package linked_list.single_linked_list;


public class SingleLinkedList {
    //先初始化一个头节点，头节点不要动
    private HeroNode head=new HeroNode(0,"",""); //不存放具体数据

    //添加节点到单向链表
    //A.当不考虑编号的顺序时：
    //1.找到链表的最后节点
    //2.将最后节点的next 指向新的节点
    public void add(HeroNode heroNode){
        //因为head节点不能动，因为我们需要一个辅助遍历 temp
        HeroNode temp=head;

        //遍历链表，找到最后
        while(true){
            //找到链表的最后
            if(temp.next==null){
                break;
            }
            //如果没有找到最后,就将temp后移
            temp=temp.next;
        }
        //当退出while循环时，temp就指向了链表的最后
        //也就是完成了2.(将最后节点的next 指向新的节点)
        temp.next=heroNode;
    }

    //B.这个添加英雄时，根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）
    public void addByOrder(HeroNode heroNode){
        //因为头节点不能动，仍然通过辅助变量找添加位置
        //因为单链表，因此找的temp位于添加位置的前一个节点，否则加不进去
        HeroNode temp=head;
        boolean flag=false;//标识：标识添加的编号是否存在，默认为false
        while(true){
            if(temp.next==null){//到最后了
                break;
            }

            //这里注意：不需要去判断temp的no是否小于node的no,因为是单向链表且while循环从head开始，相当于已经隐性判断过了
            if(temp.next.no>heroNode.no){//位置找到，就在temp后面插入（也就是说此时node应该添加在temp和temp.next之间）
                break;
            }else if (temp.next.no==heroNode.no){//说明node的编号已经存在
                flag=true;
                break;
            }
            temp=temp.next;//记得要后移，遍历当前链表
        }
        //判断flag的值
        if(flag){//不能添加
            System.out.printf("准备插入的英雄编号%d 已经存在，不能加入\n",heroNode.no);
        }else{
            //插入进链表种，temp后面
            heroNode.next=temp.next;
            temp.next=heroNode;
        }
    }


    //修改节点的信息，根据no来修改，即no不能改
    //根据newHeroNode的no来修改
    public void update(HeroNode newHeroNode){
        //判断是否为空
        if(head.next==null){
            System.out.println("链表为空");
            return;
        }
        //根据no,找到需要修改的节点
        //定义一个辅助变量
        HeroNode temp=head.next;
        boolean flag=false;//是否找到该节点

        while(true){
            if(temp==null){
                break;//到链表的结尾了，遍历完了
            }
            if(temp.no==newHeroNode.no){
                //找到了
                flag=true;
                break;
            }
            temp=temp.next;
        }
        //根据flag判断是否找到要修改的节点
        if(flag){
            temp.name=newHeroNode.name;
            temp.nickname=newHeroNode.nickname;
        }else{//没有找到
            System.out.printf("没有找到编号%d 的节点\n",newHeroNode.no);
        }
    }


    //删除节点
    //1.通过temp找待删除的前一个节点
    //2.在比较时:temp.next.no和节点no
    public void del(int no){
        HeroNode temp=head;
        boolean flag=false; //标志是否找到

        while(true){
            if(temp.next==null){//已到最后
                break;
            }

            if(temp.next.no==no){
                //找到待删除的前一个节点
                flag=true;
                break;
            }
            temp=temp.next;
        }

        //判断flag
        if(flag){//找到
            //删除
            temp.next=temp.next.next;
        }else{
            System.out.printf("%d节点不存在\n",no);
        }
    }


    //显示链表(遍历)
    public void list(){
        //先判断链表是否为空
        if(head.next==null){
            System.out.println("链表为空");
            return;
        }

        //因为头节点不能动，因此需要一个辅助变量
        HeroNode temp=head.next;
        while (true){
            //是否到最后
            if(temp==null){
                break;
            }
            //输出节点信息
            System.out.println(temp);
            //将next后移
            temp=temp.next;
        }
    }

}


//=================================================================================================================

package linked_list.single_linked_list;

//测试案例
public class Test {
    public static void main(String[] args) {
        //进行测试
        //先创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");

        //创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        //加入
//        singleLinkedList.add(hero1);
//        singleLinkedList.add(hero2);
//        singleLinkedList.add(hero3);
//        singleLinkedList.add(hero4);

        //按顺序加入
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);
//        singleLinkedList.addByOrder(hero3);
        //遍历结果
        singleLinkedList.list();

        //测试修改
        HeroNode newHeroNode=new HeroNode(2,"小卢","阿玉~");
        singleLinkedList.update(newHeroNode);
        System.out.println("=========================");
        singleLinkedList.list();



        //删除节点
        singleLinkedList.del(1);
        singleLinkedList.del(4);
        singleLinkedList.del(2);
        singleLinkedList.del(3);
        System.out.println("=========================");
        singleLinkedList.list();

    }
}

```





**面试题**

```java
//写在上面代码，那个 SingleLinkedList 类里

//面试题
    //A.方法：获取到但链表的节点的个数（如果是带头节点的链表，不统计）

    /**
     *
     * @param head 链表的头节点
     * @return 返回有效节点的个数
     */
    public static int getLength(HeroNode head){
        if(head.next==null){
            return 0;
        }

        int length=0;
        //辅助变量
        HeroNode cur=head.next;//不统计头节点
        while(cur!=null){
            length++;
            cur=cur.next;
        }
        return length;
    }
===================================================================================================================
    //B.查找单链表中的倒数第k个节点
    //思路：
    //1.方法接收head节点，同时接收一个index(index表示倒数第index个节点)
    //2.先把链表从头到尾遍历，得到链表的总长度getLength
    //3.得到size后，从链表的第一个开始遍历（size-index）个，就得到了
    //找不到返回空
    public static HeroNode findLastIndexNode(HeroNode head,int index){
       //链表为空
       if(head.next==null){
           return null;
       }

       //第一次遍历得到链表的长度
        int size=getLength(head);

       //第二次遍历 size-index位置，就是我们倒数的第k个节点
       //先做index的校验
       if(index<=0||index>size){
           return null;
       }

       //定义一个辅助变量
        HeroNode cur=head.next;
       for(int i=0;i<size-index;i++){
           cur=cur.next;
       }
       return cur;
    }
===================================================================================================================
//C.单链表的反转
    //1.先定义一个节点reverseHead=new HeroNode[];
    //2.从头到尾遍历原来的链表，每遍历一个节点，将其取出，放在新链表的最前端
    //3.原来的链表的head.next=reverseHead.next
    public static void reverseList(HeroNode head){
        //如果当前链表为空，或只有一个节点，则无需反转，直接返回
        if(head.next==null||head.next.next==null){
            return;
        }

        //定义一个辅助指针，帮助遍历原来的链表
        HeroNode cur=head.next; //cur是原链表head的后一个节点
        HeroNode next=null; //指向当前节点（cur）的下一个节点
        HeroNode reverseHead=new HeroNode(0,"","");

        //遍历原来的链表
        while(cur!=null){
            next=cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用

            cur.next=reverseHead.next;
            //这步是把连在head后面的节点，赋值给cur当前遍历节点的next,也就是将后面的节点，每遍历一次，连接一次
            reverseHead.next=cur;
            //将遍历的当前节点直接连到新链表的head上，这里用cur去做赋值，然后cur的next域又在上一步连接过了上一次遍历的节点

            cur=next;//让cur后移
        }
        //上面while已经做完了后面所有节点反转的工作

        //将head.next指向reverseHead.next,反转全部实现
        head.next=reverseHead.next;
    }

===================================================================================================================
    //D.从尾到头打印单链表（反向遍历）
    //1.方式一：先将单链表反转操作后再遍历；（但会破坏原来单链表的结构，不建议）
    //2.方式二：可以利用栈，将各个节点压入栈中，利用栈的先进后出的特点，实现逆序打印的效果
    //使用栈实现：
    public static void reversePrint(HeroNode head){
        if(head.next==null){
            return;//空链表，不能打印
        }

        //创建一个栈，节点压入栈中
        Stack<HeroNode> stack = new Stack<>();
        HeroNode cur=head.next;
        //将所有节点压入
        while(cur!=null){
            stack.push(cur);
            cur=cur.next; //后移
        }

        //将栈打印
        while(stack.size()>0){
            System.out.println(stack.pop()); //stack特点：先进后出
        }
    }
```





### 双向链表

跟单向链表相比，多了一个pre（指向前一个节点）

> 单链表存在的问题：
>
> 1.查找方向只有一个；2.不能自我删除，需要辅助节点。



操作思路：

> 分析双向链表的遍历，添加，修改，删除的操作思路：
>
> 1.**遍历**：和单链表相同，只是可以向前
>
> 2.**添加**：默认添加到双向链表的最后：
>
> ​	a. 先找到链表的最后
>
> ​	b.temp.next=new HeroNode;
>
> ​	c.new HeroNode.pre=temp;
>
> 3.**修改**：和单向链表一样
>
> 4.**删除**：
>
> ​	a.因为双向链表，因此可以实现自我删除某个节点
>
> ​	b.直接找到要删除的节点
>
> ​	c.temp.pre.next=temp.next;
>
> ​	d.temp.next.pre=temp.pre;



```java
package linked_list.double_linked_list;

//定义一个HeroNode,每一个HeroNode对象就是一个节点
public class HeroNode2 {
    public int no;
    public String name;
    public String nickname;
    public HeroNode2 next;//指向下一个节点
    public HeroNode2 pre;//指向前一个节点

    //构造器
    public HeroNode2(int no,String name,String nickname){
        this.no=no;
        this.name=name;
        this.nickname=nickname;
    }


    //为了显示方便，重写toString

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\''+
                '}';
    }
}

===================================================================================================================
    package linked_list.double_linked_list;

public class DoubleLinkedList {

    private HeroNode2 head=new HeroNode2(0,"","");

    public HeroNode2 getHead() {
        return head;
    }

    //遍历双向链表
    public void list(){
        //先判断链表是否为空
        if(head.next==null){
            System.out.println("链表为空");
            return;
        }

        //因为头节点不能动，因此需要一个辅助变量
        HeroNode2 temp=head.next;
        while (true){
            //是否到最后
            if(temp==null){
                break;
            }
            //输出节点信息
            System.out.println(temp);
            //将next后移
            temp=temp.next;
        }
    }

    //add：添到最后
    public void add(HeroNode2 heroNode){
        HeroNode2 temp=head;
        while(true){
            if(temp.next==null){
                break;
            }
            temp=temp.next;
        }
        //形成一个双向链表
        temp.next=heroNode;
        heroNode.pre=temp;
    }

    //update：双向链表的修改跟单向链表一样
    public void update(HeroNode2 newHeroNode){
        //判断是否为空
        if(head.next==null){
            System.out.println("链表为空");
            return;
        }
        //根据no,找到需要修改的节点
        //定义一个辅助变量
        HeroNode2 temp=head.next;
        boolean flag=false;//是否找到该节点

        while(true){
            if(temp==null){
                break;//到链表的结尾了，遍历完了
            }
            if(temp.no==newHeroNode.no){
                //找到了
                flag=true;
                break;
            }
            temp=temp.next;
        }
        //根据flag判断是否找到要修改的节点
        if(flag){
            temp.name=newHeroNode.name;
            temp.nickname=newHeroNode.nickname;
        }else{//没有找到
            System.out.printf("没有找到编号%d 的节点\n",newHeroNode.no);
        }
    }

    //del：删除一个节点
    //可以直接找到要删除的节点，然后自我删除
    public void del(int no){

        //判断当前链表是否为空
        if(head.next==null){
            System.out.println("链表为空，无法删除");
            return;
        }

        HeroNode2 temp=head.next;//辅助指针
        boolean flag=false; //标志是否找到

        while(true){
            if(temp==null){//已到最后
                break;
            }

            if(temp.no==no){
                flag=true;
                break;
            }
            temp=temp.next;
        }
        //判断flag
        if(flag){//找到
            //删除
            temp.pre.next=temp.next;
            //下面代码有问题：假如待删除节点是最后一个节点的话，需要一个条件。
            if(temp.next!=null) {
                temp.next.pre = temp.pre;
            }
        }else{
            System.out.printf("%d节点不存在\n",no);
        }
    }

}

//TODO:按编号顺序进行添加
===================================================================================================================
    
    package linked_list.double_linked_list;


//双向链表的测试
public class Test {
    public static void main(String[] args) {
        //先创建节点
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");
        //创建双向链表对象
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();

        //添加对象
        doubleLinkedList.add(hero1);
        doubleLinkedList.add(hero2);
        doubleLinkedList.add(hero3);
        doubleLinkedList.add(hero4);
        doubleLinkedList.list();

        //修改测试
        HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙");
        doubleLinkedList.update(newHeroNode);
        System.out.println("修改后");
        doubleLinkedList.list();

        //删除
        doubleLinkedList.del(3);
        System.out.println("删除后");
        doubleLinkedList.list();
    }
}

```



### 单向环形链表（约瑟夫）

也就是形成环了...



**约瑟夫问题**

（其实用数组取模也可以完成）

> n: 表示有几个人
>
> k: 从第k个人开始报数（1<=k<=n）
>
> m: 数m下，（从下一个开始数，数m个，出队列）



> **构建单向环形链表**的思路：
>
> 1.先创建第一个节点first，并形成环形（next指向自己）
>
> 2.后面每创建一个新节点，将该节点加入已有的环形链表中即可



> **遍历**环形链表：让一个辅助指针指向 first ，然后通过一个while循环遍历该环形链表（curboy.next==first即结束）



> **出圈**思路分析：
>
> 1.需要创建一个辅助指针helper，事先应该指向环形链表的最后一个节点
>
> 2.报数前，先移动first和helper移动k-1次
>
> 3.当报数时，让 first 和 helper 同时的移动 m-1次
>
> 4.这时就可以将 first 指向小孩节点出圈
>
> first=first.next
>
> help.next=fisrt
>
> 上面这两行代码就把节点跳过了，没有任何引用，就会被回收

```java
package linked_list.josepfu;


//节点类
public class Boy {
    private int no;
    private Boy next; //指向下一个节点

    public Boy(int no){
        this.no=no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
===================================================================================================================
    package linked_list.josepfu;

//创建环形单向链表类
public class CircleSingleLinkedList {
    //先创建一个first节点
    private Boy first=null;
    //添加小孩节点，构建成环形链表
    public void addBoy(int nums){ //nums表示加几个小孩
        //对nums做数据校验
        if(nums<1){
            System.out.println("nums不正确");
            return;
        }
        Boy curBoy=null; //辅助指针，帮助构建环形链表
        //使用for循环创建环形链表
        for (int i = 1; i <= nums; i++) {
            //根据编号创建小孩节点
            Boy boy = new Boy(i);
            //如果是第一个小孩
            if(i==1){
                first=boy;
                first.setNext(first);//自己构成一个环了
                curBoy=first;//让curBoy指向第一个小孩
            }else{
                curBoy.setNext(boy); //先让当前节点跟新节点挂起来
                boy.setNext(first);//将新节点跟first节点挂起来
                curBoy=boy;//然后将辅助指针向后移，指向新移进来的节点
            }
        }
    }

    //遍历当前环形链表
    public void showBoy(){
        //判断链表是否为空
        if(first==null){
            System.out.println("没人");
            return;
        }
        //因为first不能动，因此使用辅助指针
        Boy curBoy=first;
        while(true){
            System.out.printf("编号%d \n",curBoy.getNo());
            if(curBoy.getNext()==first){//遍历完毕
                break;
            }
            curBoy=curBoy.getNext();//curBoy后移
        }

    }

    /**
     *
     * @param startNo 表示从第几个开始
     * @param countNum 数几下
     * @param nums 开始时几个人
     */
    //计算小孩出圈顺序
    public void countBoy(int startNo,int countNum,int nums){
        //对数据校验
        if(first==null||startNo<1||startNo>nums){
            System.out.println("参数输入有误，请重新输入");
            return;
        }
        //创建一个辅助指针，帮助完成出圈
        Boy helper=first;

        //下面这while循环是：循环整个圈，直到下一个节点是first
        //这样的话helper指向了最后一个节点
        while(true){
            if(helper.getNext()==first){//说明helper指向最后一个节点
                break;
            }
            helper=helper.getNext();
        }

        //报数前，先移动first和helper移动k-1次
        //移动到了循环次数的位置位置
        for (int j = 0; j < startNo-1; j++) {
            first=first.getNext();
            helper=helper.getNext();
        }

        //报数时，同时移动m-1次，并出圈（循环，直到只剩一个节点）
        while(true){
            if(helper==first){//只剩一个节点了
                break;
            }
            //移动 countNum-1次
            for (int j = 0; j < countNum-1; j++) {
                first=first.getNext();
                helper=helper.getNext();
            }
            //这时first指向的节点就是出圈的节点
            System.out.printf("出圈节点%d\n",first.getNo());
            //将此节点出圈
            first=first.getNext();
            helper.setNext(first);
        }
        System.out.printf("最后留在圈中的编号%d\n",first.getNo());
    }
}

===================================================================================================================

    package linked_list.josepfu;

public class Test {
    public static void main(String[] args) {
        //测试
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);//加入5个节点
        circleSingleLinkedList.showBoy();

        //测试出圈
        circleSingleLinkedList.countBoy(1,2,5);
    }
}


```



## 栈

stack特点：

> 1.先入后出；
>
> 2.限制线性表中元素的插入和删除，都只能在线性表同一端进行，也就是栈顶（Top）；另一端是栈底（Bottom），固定不变；
>
> 3.从top放入数据(入栈push)，从top取出数据（出栈pop）。

栈的其他功能

> 1.子程序调用：也就是用一个栈记录地址
>
> 2.递归：
>
> 3.表达式的转换（中缀表达式转后缀表达书）和求值
>
> 4.二叉树的遍历
>
> 5.图形的深度优先



### 代码实现

> 思路分析：
>
> 1.用数组模拟栈：出栈，入栈，遍历；
>
> 2.定义一个top表示栈顶，初始化为-1；
>
> 3.入栈的操作，当有数据加入栈时，top++; stack[top]=data;
>
> 4.出栈的操作， int value=stack[top]; top--;return value;

```java
package stack;


//定义一个类，表示栈（用数组模拟的）
public class ArrayStack {
    private int maxSize; //栈的大小
    private int[] stack; //数组，模拟栈，数据放在数组中
    private int top=-1; //top表示栈顶，初始化为-1

    //构造器
    public ArrayStack(int maxSize){
        this.maxSize=maxSize;
        stack=new int[this.maxSize];
    }

    //栈满
    public boolean isFull(){
        return top==maxSize-1;
    }

    //栈空
    public boolean isEmpty(){
        return top==-1;
    }

    //入栈
    public void push(int value){
        //判断栈是否满
        if(isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top]=value;
    }

    //出栈,将栈顶数据返回
    public int pop(){
        //判断是否空
        if(isEmpty()){
            //抛出异常
            throw new RuntimeException("栈空");
        }
        int value=stack[top];
        top--;
        return value;
    }

    //遍历时，需要从栈顶开始显示
    public void list(){
        //为空？
        if(isEmpty()){
            System.out.println("栈空");
            return;
        }
        for (int i = top; i >=0 ; i--) {
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }
}
===================================================================================================================
    package stack;

import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        //测试
        //先创建对象
        ArrayStack stack = new ArrayStack(4);
        String key="";
        boolean loop=true;

        Scanner sc = new Scanner(System.in);

        while(loop){
            System.out.println("show:显示栈");
            System.out.println("exit:退出栈");
            System.out.println("push:入栈");
            System.out.println("pop:出栈");
            System.out.println("先输入：");
            key=sc.next();
            switch (key){
                case "show":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入：");
                    int value = sc.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try{
                        int res=stack.pop();
                        System.out.println("出栈的数据是 "+res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    sc.close();
                    loop=false;
                    break;
            }

        }
        System.out.println("程序退出");
    }
}

```



### 综合计算器的实现

> 思路分析：
>
> 1. 通过一个index(指针、索引)遍历表达式
>
> 2. 如果发现是数字，直接入数栈（numStack）
>
> 3. 如果发现是符号，就分情况解决：
>
>    a.如果发现当前符号栈（operStack）为空，直接入栈
>
>    b.如果不为空进行比较，如果当前操作符的优先级<=栈中操作符，就需要数栈中pop出两个数再从符号栈中pop出一个符号，进行运行，将结果入数栈，然后将当前符号入符号栈;
>
>    c.如果优先级>,则直接入栈
>
> 4. 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行
>
> 5. 如果最后数栈只有一个数字，就是表达式结果

```java
package stack.calculator_stack;


//创建一个栈
public class ArrayStack2 {
    private int maxSize; //栈的大小
    private int[] stack; //数组，模拟栈，数据放在数组中
    private int top=-1; //top表示栈顶，初始化为-1

    //构造器
    public ArrayStack2(int maxSize){
        this.maxSize=maxSize;
        stack=new int[this.maxSize];
    }
    //返回当前栈顶的值，不是真正出栈
    public int peek(){
        return stack[top];
    }

    //栈满
    public boolean isFull(){
        return top==maxSize-1;
    }

    //栈空
    public boolean isEmpty(){
        return top==-1;
    }

    //入栈
    public void push(int value){
        //判断栈是否满
        if(isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top]=value;
    }

    //出栈,将栈顶数据返回
    public int pop(){
        //判断是否空
        if(isEmpty()){
            //抛出异常
            throw new RuntimeException("栈空");
        }
        int value=stack[top];
        top--;
        return value;
    }

    //遍历时，需要从栈顶开始显示
    public void list(){
        //为空？
        if(isEmpty()){
            System.out.println("栈空");
            return;
        }
        for (int i = top; i >=0 ; i--) {
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }


    //返回运算符的优先级，优先级是程序员确定的，优先级通过数字表示，数字越大，优先级越高
    public int priority(int oper){ //假设只有加减乘除
        if(oper=='*'||oper=='/'){
            return 1;
        }else if(oper=='+'||oper=='-'){
            return 0;
        }else{
            return -1;
        }
    }

    //判断是不是运算符
    public boolean isOper(char val){
        return val=='+'||val=='-'||val=='*'||val=='/';
    }

    //计算方法
    public int cal(int num1,int num2,int oper){
        int res=0; //用于存放结果
        switch (oper){
            case '+':
                res=num1+num2;
                break;
            case '-':
                res=num2-num1; //注意顺序
                break;
            case '*':
                res=num1*num2;//注意顺序
                break;
            case '/':
                res=num2/num1;//注意顺序
                break;
        }
        return res;
    }
}
===================================================================================================================
    package stack.calculator_stack;


//根据思路，完成表达式的运算
public class Test {
    public static void main(String[] args) {
        String expression="7*2*2-5+1-5+3-4";
        //创建两个栈，数栈和符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //定义需要的相关变量
        int index=0;//用于扫描
        int num1=0;
        int num2=0;
        int oper=0;
        int res=0;
        char ch=' '; //将每次扫描得到的char保存到ch中
        String keepNum="";//用于拼接多位数的

        //开始while循环扫描expression
        while(true){
            //依次得到expression的每一个字符
            ch = expression.substring(index, index + 1).charAt(0);
            //判断ch是什么，做相应处理
            if(operStack.isOper(ch)){//如果是运算符
                //判断当前符号栈是否为空
                if(!operStack.isEmpty()){
                    //如果当前操作符的优先级<=栈中操作符
                    //数栈中pop出两个数再从符号栈中pop出一个符号，进行运行，将结果入数栈
                    if(operStack.priority(ch)<=operStack.priority(operStack.peek())){
                        num1=numStack.pop();
                        num2=numStack.pop();
                        oper=operStack.pop();
                        res=numStack.cal(num1,num2,oper);
                        //结果放入数栈
                        numStack.push(res);
                        //当前符号入栈
                        operStack.push(ch);
                    }else{
                        //如果优先级>,则直接入栈
                        operStack.push(ch);
                    }
                }else{
                    //为空，直接入栈
                    operStack.push(ch);
                }
            }else{ //如果是数，直接入数栈
                //numStack.push(ch-48); //注意这里！！这个时候是char
                //分析思路：
                //1.处理多位数时，不能立即入栈，因为可能是多位数
                //2.在处理数是，需要向expression的表达式的index,再后看一位，如果是数继续扫描，如果是符号才入栈
                //3.因此需要一个字符串变量，用于拼接
                keepNum+=ch;
                //如果ch已经是expression的最后一位，直接入栈
                if(index==expression.length()-1){
                    numStack.push(Integer.parseInt(keepNum));
                }else {
                    //判断下一位字符是不是数字
                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) {
                        //是操作符，则入栈
                        numStack.push(Integer.parseInt(keepNum));
                        //重要！！
                        keepNum = "";
                    }
                }
            }
            //让index+1，并判断是否到结尾了
            index++;
            if(index>=expression.length()){
                break;
            }
        }
        //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行
        while(true){
            //如果符号栈为空，则计算到最后结果，数栈中一个数字了（结果）
            if(operStack.isEmpty()){
                break;
            }
            num1=numStack.pop();
            num2=numStack.pop();
            oper=operStack.pop();
            res=numStack.cal(num1,num2,oper);
            //结果放入数栈
            numStack.push(res);
        }
        //pop出
        System.out.printf("表达式%s = %d",expression,numStack.pop());
    }
}

```



### 栈的三种表达式

**前缀** ：波兰表达式

运算符位于操作数之前

> 例如：(3+4)x5-6 的前缀表达式： - x + 3 4 5 6
>
> （1）**从右向左**扫描，按顺序将6，5，4，3压入堆栈
>
> （2）遇到+，弹出3和4（栈顶元素和次顶元素），计算得到7，结果压入栈
>
> （3）然后是x，弹出7和5，计算得到35，结果压入栈
>
> （4）最后-，计算得到35-6，得到29，最终结果



**中缀**

最熟悉的：(3+4)x5-6 的中缀表达式就是正常顺序

但计算机不好计算，一般转成其他表达式（后缀表达式最常见）

> **中缀转后缀**表达式：1+((2+3)x 4)-5 => 后缀
>
> 1. 初始化两个栈：运算符s1，存储中间结果s2
>
> 2. 从左至右扫描中缀表达式，遇到数字压入s2；
>
> 3. 遇到运算符，比较其与s1栈顶的优先级：
>
>    （1）如果栈空或栈顶是"("，直接入栈；
>
>    （2）优先级高于栈顶，入栈;
>
>    （3）否则，栈顶弹出，压入s2，再次转到3.（1）与s1中新的栈顶运算符比较。
>
> 4. 遇到括号时：
>
>    （1）如果是"("，则直接压入s1;
>
>    （2）如果是")"，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时丢弃这对括号。
>
> 5. 直到表达式最右边，将s1中剩余的运算符依次弹出并压入s2。
>
> 6. 逆序弹出s2中的元素就是最后结果，中缀表达式对应的后缀表达式。

```java
package stack.infix_to_suffix;

import stack.polland_notation.PolandNotation;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

//中缀转后缀
public class InfixToSuffix {
    public static void main(String[] args) {
        //说明
        //1.1+((2+3)x4)-5 => 转成 1 2 3 + 4 x + 5 -
        //2.因为直接对str进行操作，不方便，因此先将“1+((2+3)x4)-5” => 中缀的表达式对应的List
        // 即“1+((2+3)x4)-5” => ArrayList [1,+,(,(,2,+,3,),x,4,),-,5]
        //3.将得到的中缀表达式对应的list => 后缀表达式对应的list
        // 即ArrayList [1,+,(,(,2,+,3,),x,4,),-,5] => ArrayList [1,2,3,+,4,x,+,5,-]

        String expression="1+((2+3)*4)-5";
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println("中缀表达式对应的List:"+infixExpressionList); //[1, +, (, (, 2, +, 3, ), x, 4, ), -, 5]
        List<String> parseSuffixExpressionList = parseSuffixExpressionList(infixExpressionList);
        System.out.println("后缀表达式对应的List:"+parseSuffixExpressionList);//[1, 2, 3, +, 4, *, +, 5, -]

        System.out.println("expression="+PolandNotation.calculate(parseSuffixExpressionList));
    }

    //方法：将中缀表达式转成对应的List
    public static List<String> toInfixExpressionList(String s){
        //定义一个list,存放中缀表达式对应的内容
        List<String> ls=new ArrayList<String>();
        int i=0;//这是一个指针，用于遍历中缀表达式字符串
        String str;//对多位数的拼接
        char c; //每遍历到一个字符，就放入到c
        do{
            //如果c是一个非数字,就需要加入到ls
            if((c=s.charAt(i))<48||(c=s.charAt(i))>57) { //不是一个数
                ls.add(""+c);
                i++;//i要后移
            }else{//如果是一个数，需要考虑多位数
                str="";//先将str 置成"" '0'[48]->'9'[57]
                while(i<s.length() && (c=s.charAt(i))>=48 && (c=s.charAt(i))<=57 ){
                    str+=c;//拼接
                    i++;
                }
                ls.add(str);
            }
        }while(i<s.length());
        return ls;
    }

    //即ArrayList [1,+,(,(,2,+,3,),x,4,),-,5] => ArrayList [1,2,3,+,4,x,+,5,-]
    //方法：将得到的中缀表达式对应的list => 后缀表达式对应的list
    public static List<String> parseSuffixExpressionList(List<String> ls){
        //定义两个栈
        Stack<String> s1=new Stack<String>();//符号栈

        //Stack<String> s2=new Stack<String>();//存储中间结果的栈
        //因为s2这个栈在整个转换过程中，没有pop操作，后面还要逆序操作
        //因此比较麻烦，就不用stack了，直接用ArrayList
        List<String> s2 = new ArrayList<>(); //存储中间结果的list

        //遍历ls
        for (String item:ls) {
            //如果是一个数，加入到s2
            if(item.matches("\\d+")){
                s2.add(item);
            } else if(item.equals("(")){
                s1.push(item);
            } else if (item.equals(")")){
                //依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时丢弃这对括号
                while(!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop();//！！将‘（’弹出s1栈,消除小括号
            }else{
                //当item的优先级<=栈顶运算符,栈顶弹出，压入s2，再次转到3.（1）与s1中新的栈顶运算符比较。
                //问题：我们缺少一个比较优先级高低的方法
                while(s1.size()!=0 && Operation.getValue(s1.peek())>=Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                //还需要item压入栈中
                s1.push(item);
            }
        }
        //将s1中剩余的运算符依次弹出并加入s2
        while(s1.size()!=0){
            s2.add(s1.pop());
        }
        return s2; //注意因为是存放到list,因此顺序输出就是结果
    }
}

```



**后缀**：逆波兰表示式

运算符位于数字之后

> 例如：(3+4)x5-6 的后缀表达式： 3 4 + 5 x 6 -
>
> （1）从左至右扫描，将3和4压入堆栈；
>
> （2）遇到+运算符，弹出4和3（栈顶元素和次顶元素），计算得到7，结果压入栈
>
> （3）将5入栈，遇到x，弹出5和7，计算得到35，结果压入栈
>
> （4）将6入栈，遇到-，计算35-6，计算得29，最终结果

```java
package stack.polland_notation;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        //先定义给逆波兰表达式
        //(3+4)x5-6 ==> 3 4 + 5 x 6 -
        //测试1：30 4 + 5 x 6 -
        //测试2：4 x 5 - 8 + 60 + 8 / 2 (中缀表达式)=> 4 5 x 8 - 60 + 8 2 / + (后缀表达式)
        //说明为了方便，逆波兰表达式的数字和符号使用空格隔开
        String suffixExpression = "4 5 x 8 - 60 + 8 2 / +"; //76
        //思路：
        //1.先将"3 4 + 5 x 6 - " => 放到 ArrayList 中
        //2.将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算
        List<String> list = getListString(suffixExpression);
        System.out.println("rpnList="+list);

        int res=calculate(list);
        System.out.println("计算的结果是="+res);
    }

    //将一个逆波兰表达式，依次将数据和运算符 放入到 ArrayList 中
    public static List<String> getListString(String suffixExpression){
        //将suffixExpression分割
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String ele:split) {
            list.add(ele);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    /*
    *（1）从左至右扫描，将3和4压入堆栈；

     （2）遇到+运算符，弹出4和3（栈顶元素和次顶元素），计算得到7，结果压入栈

     （3）将5入栈，遇到x，弹出5和7，计算得到35，结果压入栈

     （4）将6入栈，遇到-，计算35-6，计算得29，最终结果
     */
    public static int calculate(List<String> ls){
        //创建个栈，一个即可
        Stack<String> stack=new Stack<String>();
        //遍历 ls
        for (String item: ls) {
            //使用正则表达式取出数
            if(item.matches("\\d+")){//多位数
                //入栈
                stack.push(item);
            }else{ //如果不是数，说明是符号，根据上面所说的逻辑，符号拿出来做运算
                //pop出两个数，并运算, 再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res=0;
                if(item.equals("+")){
                    res=num1+num2;
                }else if(item.equals("-")){
                    res=num1-num2;
                }else if(item.equals("x")){
                    res=num1*num2;
                }else if(item.equals("/")){
                    res=num1/num2;
                }else{
                    throw new RuntimeException("运算符有误");
                }
                //把res入栈
                stack.push(res+"");
            }
        }
        //最后留在stack中的数据，就是运算结果
        return Integer.parseInt(stack.pop());
    }
}

```



逆波兰计算器完整版

> 1.支持 + - * / ()
>
> 2.多位数，支持小数
>
> 3.兼容处理，过滤任何空白字符，包括空格、制表符、换页符

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.regex.Pattern;

public class ReversePolishMultiCalc {

     /**
     * 匹配 + - * / ( ) 运算符
     */
    static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)";

    static final String LEFT = "(";
    static final String RIGHT = ")";
    static final String ADD = "+";
    static final String MINUS= "-";
    static final String TIMES = "*";
    static final String DIVISION = "/";

    /**
     * 加減 + -
     */
    static final int LEVEL_01 = 1;
    /**
     * 乘除 * /
     */
    static final int LEVEL_02 = 2;

    /**
     * 括号
     */
    static final int LEVEL_HIGH = Integer.MAX_VALUE;


    static Stack<String> stack = new Stack<>();
    static List<String> data = Collections.synchronizedList(new ArrayList<String>());

    /**
     * 去除所有空白符
     * @param s
     * @return
     */
    public static String replaceAllBlank(String s ){
        // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]
        return s.replaceAll("\\s+","");
    }

    /**
     * 判断是不是数字 int double long float
     * @param s
     * @return
     */
    public static boolean isNumber(String s){
        Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$");
        return pattern.matcher(s).matches();
    }

    /**
     * 判断是不是运算符
     * @param s
     * @return
     */
    public static boolean isSymbol(String s){
        return s.matches(SYMBOL);
    }

    /**
     * 匹配运算等级
     * @param s
     * @return
     */
    public static int calcLevel(String s){
        if("+".equals(s) || "-".equals(s)){
            return LEVEL_01;
        } else if("*".equals(s) || "/".equals(s)){
            return LEVEL_02;
        }
        return LEVEL_HIGH;
    }

    /**
     * 匹配
     * @param s
     * @throws Exception
     */
    public static List<String> doMatch (String s) throws Exception{
        if(s == null || "".equals(s.trim())) throw new RuntimeException("data is empty");
        if(!isNumber(s.charAt(0)+"")) throw new RuntimeException("data illeagle,start not with a number");

        s = replaceAllBlank(s);

        String each;
        int start = 0;

        for (int i = 0; i < s.length(); i++) {
            if(isSymbol(s.charAt(i)+"")){
                each = s.charAt(i)+"";
                //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 && 操作符优先级不是( )的优先级 及是 ) 不能直接入栈
                if(stack.isEmpty() || LEFT.equals(each)
                        || ((calcLevel(each) > calcLevel(stack.peek())) && calcLevel(each) < LEVEL_HIGH)){
                    stack.push(each);
                }else if( !stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())){
                    //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈
                    while (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek()) ){
                        if(calcLevel(stack.peek()) == LEVEL_HIGH){
                            break;
                        }
                        data.add(stack.pop());
                    }
                    stack.push(each);
                }else if(RIGHT.equals(each)){
                    // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
                    while (!stack.isEmpty() && LEVEL_HIGH >= calcLevel(stack.peek())){
                        if(LEVEL_HIGH == calcLevel(stack.peek())){
                            stack.pop();
                            break;
                        }
                        data.add(stack.pop());
                    }
                }
                start = i ;    //前一个运算符的位置
            }else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+"") ){
                each = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1);
                if(isNumber(each)) {
                    data.add(each);
                    continue;
                }
                throw new RuntimeException("data not match number");
            }
        }
        //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/ ，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列
        Collections.reverse(stack);
        data.addAll(new ArrayList<>(stack));

        System.out.println(data);
        return data;
    }

    /**
     * 算出结果
     * @param list
     * @return
     */
    public static Double doCalc(List<String> list){
        Double d = 0d;
        if(list == null || list.isEmpty()){
            return null;
        }
        if (list.size() == 1){
            System.out.println(list);
            d = Double.valueOf(list.get(0));
            return d;
        }
        ArrayList<String> list1 = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            list1.add(list.get(i));
            if(isSymbol(list.get(i))){
                Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));
                list1.remove(i);
                list1.remove(i-1);
                list1.set(i-2,d1+"");
                list1.addAll(list.subList(i+1,list.size()));
                break;
            }
        }
        doCalc(list1);
        return d;
    }

    /**
     * 运算
     * @param s1
     * @param s2
     * @param symbol
     * @return
     */
    public static Double doTheMath(String s1,String s2,String symbol){
        Double result ;
        switch (symbol){
            case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break;
            case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break;
            case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break;
            case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break;
            default : result = null;
        }
        return result;

    }

    public static void main(String[] args) {
        //String math = "9+(3-1)*3+10/2";
        String math = "12.8 + (2 - 3.55)*4+10/5.0";
        try {
            doCalc(doMatch(math));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```





## 递归

递归就是自己调用自己，每次调用时传入不同的变量。

```java
package stack.recursion;

public class Recursion {
    public static void main(String[] args) {
        test(4);

        int n=4;
        System.out.printf("%d的阶乘结果是：%d",n,factorial(n));
    }


    /*递归调用机制的讲解：
    * 1.当程序执行到一个方法时，就会开辟一个独立的空间（栈）
    * 2.每个空间的数据（局部变量），是独立的
    * 3.如果方法中使用的是引用类型变量，就会共享该引用类型的数据
    * 4.必须逼近递归条件，否则无限递归，出现StackOverflowError,栈溢出
    * 5.当方法执行完毕，或遇到return就会返回
    * */

    //打印问题：
    public static void test(int n){
        if(n>2){
            test(n-1);
        }
        System.out.println("n="+n);
    }

    //阶乘问题：
    public static int factorial(int n){
        if(n==1){
            return 1;
        }else{
            return n*factorial(n-1);
        }
    }
}
```

调用机制图解：

<img src="C:\Users\TIAN Yixin\AppData\Roaming\Typora\typora-user-images\image-20230124111118329.png" alt="image-20230124111118329" style="zoom: 50%;" />



### 迷宫

```java
package stack.recursion;

public class MiGong {
    public static void main(String[] args) {
        //先创建一个二维数组，先模拟迷宫
        //地图
        int[][] map = new int[8][7];
        //使用1表示墙
        //上下全部置为1
        for (int i = 0; i < 7; i++) {
            map[0][i]=1;
            map[7][i]=1;
        }

        //左右全部置为1
        for (int i = 0; i < 8; i++) {
            map[i][0]=1;
            map[i][6]=1;
        }

        //设置挡板，1表示
        map[3][1]=1;
        map[3][2]=1;

        //map[1][2]=1;
        //map[2][2]=1;
        //输出地图
        System.out.println("地图如下：");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }

        //使用递归回溯，给小球走路
        //setWay(map,1,1);
        setWay2(map,1,1);

        //在输出新的地图=> 探测并标识过的地图
        System.out.println("地图如下：");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }
    }


    //使用递归回溯来给小球找路
    //(i,j)初始(1,1); (6,5)终止
    //当map[i][j]为0表示该点没走过，当为1表示墙，为2表示通路可以走，3表示该点已经走过，但是走不通
    //策略（方法）：先走下->右->上->左,如果该点走不通再回溯

    /**
     *
     * @param map 地图
     * @param i 开始的位置的行
     * @param j 开始的位置的列
     * @return 如果找到路，返回true,否则返回false
     */
    public static boolean setWay(int[][] map, int i, int j){
        if(map[6][5]==2){//通路已经找到ok
            return true;
        }else{
            if(map[i][j]==0){//如果当前这个点还没有走过
                //按照策略走
                map[i][j]=2; //假定该点是可以走通
                if(setWay(map,i+1,j)){//向下走
                    return true;
                }else if(setWay(map,i,j+1)){//右
                    return true;
                }else if(setWay(map,i-1,j)){//上
                    return true;
                }else if (setWay(map,i,j-1)){
                    return true;
                }else{//说明该点走不通，是死路
                    map[i][j]=3;
                    return false;
                }
            }else{//如果map[i][j]!=0,可能是1，2，3
                return false;
            }
        }
    }


    //修改找路的策略，改成 上右下左
    public static boolean setWay2(int[][] map, int i, int j){
        if(map[6][5]==2){//通路已经找到ok
            return true;
        }else{
            if(map[i][j]==0){//如果当前这个点还没有走过
                //按照策略走
                map[i][j]=2; //假定该点是可以走通
                if(setWay2(map,i-1,j)){//向上走
                    return true;
                }else if(setWay2(map,i,j+1)){//右
                    return true;
                }else if(setWay2(map,i+1,j)){//下
                    return true;
                }else if (setWay2(map,i,j-1)){ //左
                    return true;
                }else{//说明该点走不通，是死路
                    map[i][j]=3;
                    return false;
                }
            }else{//如果map[i][j]!=0,可能是1，2，3
                return false;
            }
        }
    }
}

```

**问题：如何找最短路径？**

思路：所有情况放进一个数组，比较所有，找到最短 => 代码实现



### 八皇后问题

8X8棋格上，任意两个皇后不能处于同一行、同一列或同一斜线上，问多少种摆法？（92种）

> 思路分析：
>
> 1.第一个皇后第一行第一列
>
> 2.第二个皇后放在第二行第一列，判断是否ok,不ok第二行、第三行...
>
> 3.第三个皇后一样...
>
> 4.得到正确解时，栈回到上一个栈，开始回溯。也就是，得到第一个皇后放在第一列的所有正确解。
>
> 5.再回头继续第一个皇后放第二列，后面循环执行第三列...

说明：理论上可以二维数组模拟棋盘，但实际上可以通过算法，用一维数组解决。arr[8]={0,4,7,5,2,6,1,3}

下标表示第几行，第几个皇后，arr[i]=val,val表示第 i+1 个皇后，放在i+1行的第val+1列

```java
package recursion.queen;

public class Queen8 {

    //定义一个max表示共用多少个皇后
    int max=8;
    //定义数组arr，保存皇后位置放置的结果
    int[] array= new int[max];
    static int count=0;
    static int judgeCount=0;

    public static void main(String[] args) {
        //测试
        Queen8 queen8 = new Queen8();
        queen8.check(0);
        System.out.println("解法总数："+count);
        System.out.println("冲突次数："+judgeCount);
    }

    //编写一个方法，放置第n个皇后
    //特别注意：check是每一次递归时，进入check,都会进入一次for循环，回溯在这呢
    

    private void check(int n){ //n=0
        if(n==max){//n==8了，其实8个皇后就已然放好了
            print(); //走了92次
            return;
        }
        //依次放入皇后，并判断是否冲突
        for (int i = 0; i < max; i++) { //遍历第一个皇后的位置
            array[n]=i; //n=0,i=0的时候，就是第一行的第一列
            //判断当放置第n个皇后到i列时，是否跟之前放置的皇后冲突
            //judgeCount++;
            if(judge(n)){//没有冲突才会开始放置下一个皇后
                //接着放n+1个皇后，即开始递归
                check(n+1); //注意：check在不停的递归
            }
            //如果冲突，也就是if不满足的话，for循环会往下走，i会++，n（行）的位置没变，往右移了一位（列+1）
        }

        //注意：每次check进入check,也就是递归，递归完成后会返回上一层的递归，所以回溯改位置是从后往前来的。
        //这里就是for循环遍历完了，也没有结果或者n==Max里，就开始返回上一层
    }

    
    //查看当我们放置第n个皇后时，就去检查该皇后是否和前面已经摆放的皇后冲突
    /**
     *
     * @param n:表示第n个皇后
     * @return
     */
    private boolean judge(int n){
        for (int i = 0; i < n; i++) {
            //说明
            //array[i]==array[n] 检测是否在同一列
            //Math.abs(n-i)==Math.abs(array[n]-array[i]) 表示第n个皇后是否跟第i个是否同一斜线，就是行的差是否等于列的差
            //没有必要判断是否同一行，因为n一直在递增
            if(array[i]==array[n]||Math.abs(n-i)==Math.abs(array[n]-array[i])){
                return false;
            }
        }
        return true;
    }


    //写一个方法，将皇后摆放的位置输出
    private void print(){
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]+" ");
        }
        System.out.println();
    }
}

```







## 时间和空间复杂度

时间复杂度

> 事后统计法：先运行后，再比较。但依赖于硬件。
>
> 事前估算法：先分析算法的时间复杂度来判断。

### 时间频度

> 一个算法花费的时间与语句的执行次数成正比。语句执行的次数称为时间频度（语句频度）。记为T(n)。
>
> 可以忽略：常数项、系数、低次项

### 时间复杂度

> 某个辅助函数 f(n)，随着n趋于无穷大，如果使得T(n)/f(n)的极限值不为0，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n)=O(f(n)).
>
> O(f(n))为算法的渐进时间复杂度，简称时间复杂度。



> 计算方法：
>
> （1）用常数1代替T(n)中所有加法常数；
>
> （2）只保留最高阶项；
>
> （3）去除最高阶项的系数。

### 常见的时间复杂度

> 1. **O(1) —** 常数复杂度
> 2. **O(log n) —** 对数复杂度
> 3. **O(n) —** 线性复杂度
> 4. **O(n log n) —** 对数线性复杂度
> 5. **O(nᵏ) —** 多项式复杂度
> 6. **O(kⁿ) —** 指数复杂度
> 7. **O(n!) —** 阶乘复杂度

<img src="C:\Users\TIAN Yixin\AppData\Roaming\Typora\typora-user-images\image-20230126134006138.png" alt="image-20230126134006138" style="zoom: 67%;" />

### 平均时间复杂度

> 所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。

### 最坏时间复杂度

> 最坏情况下的时间复杂度是算法再任何输入实例上运行时间的界限。

**=======================================================================================================**

### 空间复杂度

> 计算在运算过程中，临时占用存储空间大小的量度。例如，随n的增大而增大，如快速排序和归并排序。





## 排序算法

> Sort Algorithm：
>
> 内部排序：在内存中完成排序（插入排序、选择排序、交换排序、归并排序、基数排序）；
>
> 外部排序：数据量很大，借助外部存储进行排序。

### 冒泡排序

> Bubble Sorting: 从下标小的元素开始，依次比较相邻元素的值，若发现逆序则交换。
>
> 第一趟排序：依次比较，找到最大值；
>
> 第二趟排序：除去上次找到的最大值，再按第一趟的，排序前面的元素；
>
> 后面就重复上述步骤...
>
> 
>
> 规则：
>
> 1. 一共进行数组大小-1次的循环（趟）
> 2. 每一趟排序的次数在逐渐减少
> 3. 如果我们发现，在某趟排序中，没有发生一次交换，可以提前结束冒泡排序（优化）

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class BubbleSort {

    public static void main(String[] args) {
        int arr[]={3,9,-1,10,20};

        //为了容易理解，展示一下冒泡排序的演变过程

        /**
        //第一趟排序，最大的数排在最后
        int temp=0; //临时变量
        for (int j = 0; j < arr.length-1; j++) {
            //如果前面的数比后面的数大，则交换
            if(arr[j]>arr[j+1]){
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
        System.out.println("第一趟排序结果:");
        System.out.println(Arrays.toString(arr));


        //第二趟排序，第二大的数排在倒数第二位
        for (int j = 0; j < arr.length-1-1; j++) {
            //如果前面的数比后面的数大，则交换
            if(arr[j]>arr[j+1]){
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
        System.out.println("第二趟排序结果:");
        System.out.println(Arrays.toString(arr));


        //第三趟排序，第三大的数排在倒数第三位
        for (int j = 0; j < arr.length-1-1-1; j++) {
            //如果前面的数比后面的数大，则交换
            if(arr[j]>arr[j+1]){
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
        System.out.println("第三趟排序结果:");
        System.out.println(Arrays.toString(arr));


        //第四趟排序，第四大的数排在倒数第四位
        for (int j = 0; j < arr.length-1-1-1-1; j++) {
            //如果前面的数比后面的数大，则交换
            if(arr[j]>arr[j+1]){
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
        System.out.println("第四趟排序结果:");
        System.out.println(Arrays.toString(arr));
        **/
        System.out.println("========================================");
//        bubbleSort(arr);

        //测试冒泡排序的速度：给80000个数据
        //创建一个80000个数据的随机数组
        int[] arr0=new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr0[i]=(int)(Math.random()*8000000); //生成一个[0,8000000)数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(data1);
        System.out.println("排序前的时间是="+date1Str);

        //排序
        bubbleSort(arr0);

        Date data2 = new Date();
        String date2Str=simpleDateFormat.format(data2);
        System.out.println("排序后的时间是="+date2Str);
        
        //8秒
    }

    //前面的过程都一直在重复，将for循环包起来
    //将冒泡排序算法，封装成一个方法
    //冒泡排序的时间复杂度：O(n^2)
    public static void bubbleSort(int[] arr){
        int temp=0; //临时变量
        boolean flag=false; //标识变量，表示是否进行过交换
        for (int i = 0; i < arr.length-1; i++) {
            for (int j = 0; j < arr.length-1-i; j++) {
                //如果前面的数比后面的数大，则交换
                if(arr[j]>arr[j+1]){
                    flag=true;
                    temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }
            if(!flag){//false,说明在一趟排序中，一次交换都没有发生过
                break;
            }else{
                flag=false; //重置flag,进行下一次判断
            }
//            System.out.println("排序结果:");
//            System.out.println(Arrays.toString(arr));
        }
    }

}
```





### 选择排序

> 内部排序，基本思想：
>
> 从0~n-1数组中选取最小数，与arr[0]交换；
>
> 再从1~n-1中选择最小数，与arr[1]交换；
>
> ... ...
>
> 总共n-1次。
>
> 
>
> 说明：
>
> 1.选择排序一共有数组-1轮排序
>
> 2.每一轮排序，又是一个循环，循环的规则：
>
> ​	（1）先假定当前数为最小数
>
> ​	（2）然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标
>
> ​	（3）遍历到数组最后，得到本轮最小数和下标
>
> ​	（4）交换

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class SelectSort {
    public static void main(String[] args) {
        int[] arr={101,34,119,1};
        selectSort(arr);
        System.out.println("排序结果：");
        System.out.println(Arrays.toString(arr));

        //测试选择排序的速度：给80000个数据
        //创建一个80000个数据的随机数组
        int[] arr0=new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr0[i]=(int)(Math.random()*8000000); //生成一个[0,8000000)数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(data1);
        System.out.println("排序前的时间是="+date1Str);

        //排序
        selectSort(arr0);

        Date data2 = new Date();
        String date2Str=simpleDateFormat.format(data2);
        System.out.println("排序后的时间是="+date2Str);
        //2s,还很稳定
    }

    //选择排序
    //时间复杂度：O(n^2)
    public static void selectSort(int[] arr){
        //使用逐步推导的方式，进行选择排序
        //算法思想：先简单，再复杂。就是可以把一个复杂的算法，拆分成简单的问题，再逐步解决
        for (int i = 0; i < arr.length-1; i++) {
            int minIndex = i;
            int min = arr[i];
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]) {//说明假定的最小值，不是最小值
                    min = arr[j];//重置min
                    minIndex = j;//重置minIndex
                }
            }
            //交换：将最小值，放在arr[0]
            if (minIndex != i) {
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
//            System.out.println("排序结果：");
//            System.out.println(Arrays.toString(arr)); //1,34,119,101
        }
    }
}
```



### 插入排序

> 内部排序，以插入的方式寻找该元素的位置。
>
> 
>
> 思想：
>
> 1.n个待排序元素看成一个有序表和一个无序表
>
> 2.开始时有序表中包含一个元素，无序表包含 n-1 元素
>
> 3.从无序表中取出的元素跟有序表中的元素做比较，将其插入

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class InsertSort {
    public static void main(String[] args) {
        int[] arr={101,34,119,1,-1,89};
        //insertSort(arr);
        System.out.println("=============");
        int[] arr0=new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr0[i]=(int)(Math.random()*8000000); //生成一个[0,8000000)数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(data1);
        System.out.println("排序前的时间是="+date1Str);

        //排序
        sorting(arr);


        Date data2 = new Date();
        String date2Str=simpleDateFormat.format(data2);
        System.out.println("排序后的时间是="+date2Str);
        
        //0s
    }

    //插入排序
    public static void insertSort(int[] arr){
        //使用逐步推导的方式来讲解，便于理解
        //第一轮：{101,34,119,1} => {34,101,119,1}

        //定义待插入的数
        int insertVal=arr[1]; //第一轮待插入的数：arr[1]=34
        int insertIndex=0; //1-1,即arr[1]前面一个数的下标(作比较的数的下标)

        //给insertVal找到插入的位置
        //说明：
        //1.insertIndex >=0 保证在给insertVal找插入位置，不越界
        //2.insertVal <arr[insertIndex] 待插入的数，还没有找到插入位置
        //3.就需要将 arr[insertIndex] 后移
        while(insertIndex>=0 && insertVal <arr[insertIndex]){
            arr[insertIndex+1]=arr[insertIndex]; //arr[insertIndex]后移
            insertIndex--;
        }
        //当退出while循环时，说明插入的位置找到，insertIndex+1
        //举例：
        arr[insertIndex+1]=insertVal;
        System.out.println("第一轮后结果");
        System.out.println(Arrays.toString(arr));


        //第二轮
        insertVal=arr[2];
        insertIndex=2-1;
        while(insertIndex>=0 && insertVal <arr[insertIndex]){
            arr[insertIndex+1]=arr[insertIndex]; //arr[insertIndex]后移
            insertIndex--;
        }

        arr[insertIndex+1]=insertVal;
        System.out.println("第二轮后结果");
        System.out.println(Arrays.toString(arr));

        //第三轮
        insertVal=arr[3];
        insertIndex=3-1;
        while(insertIndex>=0 && insertVal <arr[insertIndex]){
            arr[insertIndex+1]=arr[insertIndex]; //arr[insertIndex]后移
            insertIndex--;
        }

        arr[insertIndex+1]=insertVal;
        System.out.println("第三轮后结果");
        System.out.println(Arrays.toString(arr));
    }

    public static void sorting(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            int insertVal=arr[i];
            int insertIndex=i-1;
            while(insertIndex >=0 && insertVal<arr[insertIndex]){
                arr[insertIndex+1]=arr[insertIndex];
                insertIndex--;
            }
            
            //这里判断是否需要赋值
            if (insertIndex+1!=i) {
                arr[insertIndex + 1] = insertVal;
            }
//            System.out.println("第"+i+"轮后结果");
//            System.out.println(Arrays.toString(arr));
        }
    }
}
```



### 希尔排序

> 插入排序存在问题：当需要的数较小时，后移的次数明显增多，对效率有影响。
>
> 希尔排序是对插入排序改进的更高效版本。
>
> 
>
> 基本思想：
>
> 1.先按数组长度除以2得到组数（这里也就是增量），分别给这几组排序
>
> 2.再按第1步得到组数再除以2，依然进行排序 （注意：第二轮是将整个数组分为两组，每组数据隔一个数一取，每组共(组长/2)个数，再进行组内排序）
>
> ...
>
> 3.直到增量为1，也就是整组进行最终排序。
>
> 
>
> 在上述过程中，数组一步步更接近有序数组。

<img src="C:\Users\TIAN Yixin\Desktop\1024555-20161128110416068-1421707828.png" alt="1024555-20161128110416068-1421707828" style="zoom: 33%;" />

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class ShellSort {
    public static void main(String[] args) {
        int[] arr={8,9,1,7,2,3,5,4,6,0};
        //测试
        //测试选择排序的速度：给80000个数据
        //创建一个80000个数据的随机数组
        int[] arr0=new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr0[i]=(int)(Math.random()*8000000); //生成一个[0,8000000)数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(data1);
        System.out.println("排序前的时间是="+date1Str);

        //排序
//        sorting(arr0);//4s
        shellSort2(arr0); //0s
        Date data2 = new Date();
        String date2Str=simpleDateFormat.format(data2);
        System.out.println("排序后的时间是="+date2Str);

    }

    //使用逐步推导的方式来编写希尔排序
    public static void shellSort(int[] arr){
        //第一轮
        //因为第一轮排序，是将10个数据分为5组
        int temp=0;
        for (int i = 5; i < arr.length; i++) {
            //遍历各组中所有的元素（共5组，每组有两个元素，所以步长是5）
            for (int j = i-5; j >=0 ; j-=5) {
                //如果当前元素大于加上步长后的元素，说明需要交换
                if(arr[j]>arr[j+5]){
                    temp=arr[j];
                    arr[j]=arr[j+5];
                    arr[j+5]=temp;
                }
            }
        }

        System.out.println("第一轮结果");
        System.out.println(Arrays.toString(arr));



        //注意：第二轮是将整个数组分为两组，每组数据隔一个数一取，每组共5个数，再进行组内排序
        //第二轮
        //因为第二轮排序，是将5个数据分为2组
        for (int i = 2; i < arr.length; i++) {
            //遍历各组中所有的元素（共5组，每组有两个元素，所以步长是5）
            for (int j = i-2; j >=0 ; j-=2) {
                //如果当前元素大于加上步长后的元素，说明需要交换
                if(arr[j]>arr[j+2]){
                    temp=arr[j];
                    arr[j]=arr[j+2];
                    arr[j+2]=temp;
                }
            }
        }

        System.out.println("第二轮结果");
        System.out.println(Arrays.toString(arr));


        //第三轮
        //因为第三轮排序，是将数据分为1组
        for (int i = 1; i < arr.length; i++) {
            //遍历各组中所有的元素（共5组，每组有两个元素，所以步长是5）
            for (int j = i-1; j >=0 ; j-=1) {
                //如果当前元素大于加上步长后的元素，说明需要交换
                if(arr[j]>arr[j+1]){
                    temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }
        }

        System.out.println("第三轮结果");
        System.out.println(Arrays.toString(arr));
    }

    public static void sorting(int[] arr){
        //交换法：
        //根据前面的逐步分析，使用循环处理
        int temp=0;
        int count=0;
        for (int gap = arr.length/2; gap >0 ; gap/=2) {
            for (int i = gap; i < arr.length; i++) {
                //遍历各组中所有的元素（共gap组，每组有?元素，所以步长是gap）
                for (int j = i - gap; j >= 0; j -= gap) {
                    //如果当前元素大于加上步长后的元素，说明需要交换
                    if (arr[j] > arr[j + gap]) {
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }
            }
//            System.out.println("第"+(++count)+"轮结果:"+Arrays.toString(arr));
        }
    }

    //对交换式的希尔排序进行优化-> 移位法
    public static void shellSort2(int[] arr){

        //增量gap,并逐步减小增量
        for (int gap = arr.length/2; gap >0 ; gap/=2){
            //从第gap个元素，逐步对其所在组进行插入排序
            for (int i = gap; i < arr.length; i++) {
                int j=i;
                int temp=arr[j];
                if(arr[j]<arr[j-gap]){
                    while(j-gap >=0&& temp<arr[j-gap]){
                        //移动
                        arr[j]=arr[j-gap];
                        j-=gap;
                    }
                    //当退出while循环后，就给temp找到插入的位置了
                    arr[j]=temp;
                }
            }
        }
    }
}
```



### 快速排序

> 对冒泡排序的一种改进。
>
> 基本思想：
>
> ​	将数组分为两部分，一部分数据要比另一部分小，然后再按此方法对这两部分数据进行快速排序。可按递归进行。
>
> ​	选取一个数（中间的数字），两侧分别找小的和大的，然后交换顺序...

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class QuickSort {
    public static void main(String[] args) {
//        int[] arr={-9,78,0,23,-567,70};
//        int[] arr={-9,78,0,23,-567,70,-1,900,4561};
        //测试：
//        quickSort(arr,0,arr.length-1);
//        System.out.println(Arrays.toString(arr));

        //测试选择排序的速度：给80000个数据
        //创建一个80000个数据的随机数组
        int[] arr0=new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr0[i]=(int)(Math.random()*8000000); //生成一个[0,8000000)数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(data1);
        System.out.println("排序前的时间是="+date1Str);

        //排序
        quickSort(arr0,0,arr0.length-1);//0s
        
        
        Date data2 = new Date();
        String date2Str=simpleDateFormat.format(data2);
        System.out.println("排序后的时间是="+date2Str);

    }

    public static void quickSort(int[] arr, int left, int right){
        int l=left;//左下标
        int r=right;//右下标

        //中轴，中间的轴
        int pivot=arr[(left+right)/2];
        int temp=0;//交换时使用
        while(l<r){ //while循环的目的是让比pivot值小的，放到左边；反之亦然。

            while(arr[l]<pivot){//在pivot左边一直找，找到大于或等于pivot值，才退出
                l+=1;
            }
            while(arr[r]>pivot){//在pivot右边一直找，找到小于或等于pivot值，才退出
                r-=1;
            }
            //如果这个条件成立，说明pivot的左右两的值，已经按照左边全部是
            //小于等于pivot值，右边全部是大于等于pivot值
            if(l>=r){
                break;
            }

            //交换
            temp=arr[l];
            arr[l]=arr[r];
            arr[r]=temp;

            //如果交换完后，发现这个arr[l]==pivot值，r--,前移
            if(arr[l]==pivot){
                r-=1;
            }
            //如果交换完后，发现这个arr[r]==pivot值，l++,后移
            if(arr[r]==pivot){
                l+=1;
            }
        }

        //如果l==r,必须l++,r--,否则必然出现栈溢出
        if(l==r){
            l+=1;
            r-=1;
        }
        //向左递归
        if(left<r){
            quickSort(arr,left,r);
        }

        //向右递归
        if(right>l){
            quickSort(arr,l,right);
        }
    }
}

```



### 归并排序

> 分治策略：大的问题分成小的问题，再递归求解。

<img src="C:\Users\TIAN Yixin\Desktop\1024555-20161218163120151-452283750.png" alt="1024555-20161218163120151-452283750" style="zoom: 33%;" />

> 以 [4,5,7,8] 和 [1,2,3,6] 合并为例：
>
> 指针 i 指向 4，指针 j 指向 1，i 和 j 比大小放 j 的位置（也就是1），然后指针 j 后移。若是 i 小于 j，则放 i 的位置，指针 i 后移

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class MergeSort {
    public static void main(String[] args) {
//        int[] arr={8,4,5,7,1,3,6,2}; //共合并length-1次


        //测试：
        //创建一个80000个数据的随机数组
        int[] arr=new int[8000000];
        int[] temp=new int[arr.length]; //归并排序需要一个额外空间
        for (int i = 0; i < 80000; i++) {
            arr[i]=(int)(Math.random()*80000); //生成一个[0,8000000)数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(data1);
        System.out.println("排序前的时间是="+date1Str);

        //排序
        mergeSort(arr,0,arr.length-1,temp);  //0s


        Date data2 = new Date();
        String date2Str=simpleDateFormat.format(data2);
        System.out.println("排序后的时间是="+date2Str);

//        System.out.println("归并排序后="+Arrays.toString(arr));
    }


    //分+合的方法
    public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if(left<right){
            int mid=(left+right)/2; //中间的索引
            //向左递归进行分解
            mergeSort(arr,left,mid,temp);
            //向右递归进行分解
            mergeSort(arr,mid+1,right,temp);
            //到合并
            merge(arr,left,mid,right,temp);
        }
    }


    /**
     *
     * @param arr 原始数组
     * @param left 左边有序序列的初始索引
     * @param mid 中间有序序列的初始索引
     * @param right 右边有序序列的初始索引
     * @param temp 做中转的数组
     */
    public static void merge(int[] arr,int left, int mid, int right, int[] temp){
//        System.out.println("🙂");
        //合并方法（最后一步）
        int i=left; //初始化i,左边有序序列的指针
        int j=mid+1; //初始化j,右边有序序列的指针
        int t=0; //temp的索引（指向temp数组的当前索引）

        //(一)
        //先把左右两边（有序）的数组按照规则填充到temp数组
        //直到左右两边的有序序列，有一边处理完毕为止
        while(i<=mid && j<=right){
            if(arr[j]<arr[i]){  //反之，将右边有序序列的当前元素，填充到temp数组
                temp[t]=arr[j];
                t+=1;
                j+=1;
            }else if(arr[j]>=arr[i]){
                //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素
                //即将左边的当前元素，拷贝到temp数组
                temp[t]=arr[i];
                i+=1;
                t+=1;
            }
        }


        //(二)
        //把有剩余数据的一边的数据依次全部填充到temp

        //如果右边有序序列有剩余元素
        while(i<=mid){
            temp[t]=arr[i];
            i+=1;
            t+=1;
        }
        while(j<=right){
            temp[t]=arr[j];
            j+=1;
            t+=1;
        }

        //(三)
        //将temp拷贝到arr
        //注意并不是每次都拷贝所有
        t=0;
        int tempLeft=left; //
        //第一次合并tempLeft=0;right=1;第二次：tempLeft=2;right=3；第三次：
        //最后一次：tempLeft=0;right=7
//        System.out.println("tempLeft="+tempLeft+" right="+right);
        while(tempLeft<=right){
            arr[tempLeft]=temp[t];
            t+=1;
            tempLeft+=1;
        }
    }
}

```





### 基数排序

> 桶排序的扩展，属于分配式排序，通过键值各个位置上的值，分配到桶（数组）中。
>
> 基数排序=>稳定的：
>
> ​	相同数据的相对次序保持不变，则称这种算法是稳定的，否则称为不稳定。
>
> ​	例如：r[i] =r[j] ，i<j ,则在排序后，依然 r[i]  在 r[j] 之前



> 基本思想：比如数组 [ 53，3，542，748，14，214 ]
>
> （1）一共10个桶（也就是一维数组，从0到9）
>
> （2）按照原数组的个位位数，放入桶中，再按顺序取出，那么第一轮结果 [ 542，53，3，14，214，748 ]
>
> （3）再按照数组的十位位数，放入桶中，再按顺序取出，第二轮结果 [ 3，14，214，543，748，53 ]
>
> （4）再按照数组的百位位数，放入桶中，再按顺序取出，第三轮结果 [ 3，14，53，214，543，748 ]
>
> 注意：
>
> 1. 小数字位数不够，则前补0；
> 2. 具体排几轮取决于数组最大的数字是几位数。
> 3. 如果有负数数组，不用基数排序来排序，或者调整代码。

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class RadixSort {
    public static void main(String[] args) {
//        int[] arr={53,3,542,748,14,214};
        //测试
//        radixSort(arr);
        //创建一个80000个数据的随机数组
        int[] arr0=new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr0[i]=(int)(Math.random()*8000000); //生成一个[0,8000000)数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(data1);
        System.out.println("排序前的时间是="+date1Str);

        //排序
        sort(arr0);//0s


        Date data2 = new Date();
        String date2Str=simpleDateFormat.format(data2);
        System.out.println("排序后的时间是="+date2Str);
    }


    //基数排序方法
    public static void radixSort(int[] arr){
        //定义一个二维数组，表示10个桶，每个桶就是一个一维数组
        //说明
        //1.二维数组包含10个一维数组
        //2.为了防止在放入数的时候，数据溢出，则每个桶大小定位arr.length
        //3.明显的，基数排序，是用空间换时间的经典算法
        int[][] bucket=new int[10][arr.length];

        //为了记录每个桶中，实际存放了多少个数据，定义一个一位数组来记录各个桶每次放入的数据个数
        int[] bucketElementCount=new int[10];   //记每个桶的

        //第一轮排序（针对个位进行排序）
        for (int j = 0; j < arr.length; j++) {
            //取出每个元素的个位
            int digitOfElement=arr[j]%10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCount[digitOfElement]]=arr[j];
            //bucketElementCount[digitOfElement]一开始是0，随着后面++，一直在往后挪
            //数组桶[对应下标(个位数)的那个桶][在哪个桶中放入[第几个位置]]
            bucketElementCount[digitOfElement]++;
        }

        //按照按顺序取出
        int index=0;
        //遍历每一个桶，并将桶中数据，放入到原数组
        for (int k = 0; k < bucketElementCount.length; k++) {
            //如果桶中有数据，我们才放入到原数组
            if(bucketElementCount[k]!=0){
                //循环该桶，即第k个桶，即第k个一维数组
                for (int l = 0; l < bucketElementCount[k]; l++) {
                    //取出原数放入到arr
                    arr[index++]=bucket[k][l];
                }
            }
            //第一轮处理后，需要将每个bucketElementCount[k]=0，否则会出问题
            bucketElementCount[k]=0;
        }
        System.out.println("第一轮="+Arrays.toString(arr));


        System.out.println("======================================");
        //第二轮排序（针对十位进行排序）
        for (int j = 0; j < arr.length; j++) {
            //取出每个元素的个位
            int digitOfElement=arr[j]/10%10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCount[digitOfElement]]=arr[j];
            //bucketElementCount[digitOfElement]一开始是0，随着后面++，一直在往后挪
            //数组桶[对应下标(个位数)的那个桶][在哪个桶中放入[第几个位置]]
            bucketElementCount[digitOfElement]++;
        }

        //按照按顺序取出
        index=0;
        //遍历每一个桶，并将桶中数据，放入到原数组
        for (int k = 0; k < bucketElementCount.length; k++) {
            //如果桶中有数据，我们才放入到原数组
            if(bucketElementCount[k]!=0){
                //循环该桶，即第k个桶，即第k个一维数组
                for (int l = 0; l < bucketElementCount[k]; l++) {
                    //取出原数放入到arr
                    arr[index++]=bucket[k][l];
                }
            }
            //第一轮处理后，需要将每个bucketElementCount[k]=0，否则会出问题
            bucketElementCount[k]=0;
        }
        System.out.println("第二轮="+Arrays.toString(arr));


        System.out.println("====================================");
        //第三轮排序（针对百位进行排序）
        for (int j = 0; j < arr.length; j++) {
            //取出每个元素的个位
            int digitOfElement=arr[j]/100%10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCount[digitOfElement]]=arr[j];
            //bucketElementCount[digitOfElement]一开始是0，随着后面++，一直在往后挪
            //数组桶[对应下标(个位数)的那个桶][在哪个桶中放入[第几个位置]]
            bucketElementCount[digitOfElement]++;
        }

        //按照按顺序取出
        index=0;
        //遍历每一个桶，并将桶中数据，放入到原数组
        for (int k = 0; k < bucketElementCount.length; k++) {
            //如果桶中有数据，我们才放入到原数组
            if(bucketElementCount[k]!=0){
                //循环该桶，即第k个桶，即第k个一维数组
                for (int l = 0; l < bucketElementCount[k]; l++) {
                    //取出原数放入到arr
                    arr[index++]=bucket[k][l];
                }
            }
        }
        System.out.println("第三轮="+Arrays.toString(arr));
    }



    public static void sort(int[] arr){
        int[][] bucket=new int[10][arr.length];
        int[] bucketElementCount=new int[10];
        //1.得到数组中最大的数的位数
        int max=arr[0];
        for (int i = 0; i < arr.length; i++) {
            if(arr[i]>max){
                max=arr[i];
            }
        }
        //得到最大数是几位数
        int maxLength=(max+"").length();

        //这里我们使用循环将代码处理一下
        for (int i = 0,n=1; i < maxLength; i++,n*=10) {
            //针对位数排序，各十百千...
            for (int j = 0; j < arr.length; j++) {
                //取出每个元素的个位
                int digitOfElement=arr[j]/n %10;
                //放入到对应的桶中
                bucket[digitOfElement][bucketElementCount[digitOfElement]]=arr[j];
                //bucketElementCount[digitOfElement]一开始是0，随着后面++，一直在往后挪
                //数组桶[对应下标(个位数)的那个桶][在哪个桶中放入[第几个位置]]
                bucketElementCount[digitOfElement]++;
            }

            //按照按顺序取出
            int index=0;
            //遍历每一个桶，并将桶中数据，放入到原数组
            for (int k = 0; k < bucketElementCount.length; k++) {
                //如果桶中有数据，我们才放入到原数组
                if(bucketElementCount[k]!=0){
                    //循环该桶，即第k个桶，即第k个一维数组
                    for (int l = 0; l < bucketElementCount[k]; l++) {
                        //取出原数放入到arr
                        arr[index++]=bucket[k][l];
                    }
                }
                //第i+1轮处理后，需要将每个bucketElementCount[k]=0，否则会出问题
                bucketElementCount[k]=0;
            }
//            System.out.println("第"+(i+1)+"轮="+Arrays.toString(arr));
        }

    }
}
```



### 堆排序

> 选择排序
>
> 完全二叉树
>
> 要求每个节点的值，都大于或等于其左右子节点的值 —> **大顶堆**（升序排序）
>
> 要求每个节点的值，都小于或等于其左右子节点的值 —> **小顶堆**（降序排序）
>
> 
>
> 基本思想：
>
> 1.先将序列构造成大顶堆 => 以数组创建树 （顺序存储二叉树）（循环: 从最后一个非叶子节点，从左至右，从上至上进行交换。从第二个非叶子节点继续）
>
> 2.整个序列的最大值 -> 根节点 
>
> 3.将根节点跟末尾元素进行交换 （数组的最后）
>
> 4.再将剩余n-1如上操作进行

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class HeapSort {
    public static void main(String[] args) {

        //要求将数组进行升序排序
//        int[] arr={4,6,8,5,9,-1,90,89,56,-999};
        int[] arr0=new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr0[i]=(int)(Math.random()*8000000); //生成一个[0,8000000)数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(data1);
        System.out.println("排序前的时间是="+date1Str);

        //排序
        heapSort(arr0); //0s


        Date data2 = new Date();
        String date2Str=simpleDateFormat.format(data2);
        System.out.println("排序后的时间是="+date2Str);
        //测试
//        heapSort(arr);
    }

    //编写一个堆排序方法
    public static void heapSort(int[] arr){
        int temp=0;
        System.out.println("堆排序");
        //分步完成
//        adjustHeap(arr,1,arr.length);
//        System.out.println("第一次"+ Arrays.toString(arr)); //4,9,8,5,6
//
//        adjustHeap(arr,0,arr.length);
//        System.out.println("第二次"+Arrays.toString(arr));

        //完成最终代码
        //完成大顶堆
        for (int i = arr.length/2-1; i >=0 ; i--) {
            adjustHeap(arr,i,arr.length);
        }

        /*
        *3.将根节点跟末尾元素进行交换 （数组的最后）
        *4.再将剩余n-1如上操作进行
        */
        for (int j = arr.length-1; j >0; j--) {
            temp=arr[j];
            arr[j]=arr[0];
            arr[0]=temp;
            adjustHeap(arr,0,j);
        }
//        System.out.println(Arrays.toString(arr));
    }

    //将一个数组（二叉树），调整成一个大顶堆

    /**
     * 功能：完成将以i对应的非叶子节点的树，调整成大顶堆
     * 举例：4,6,8,5,9 => arr.length/2-1 (调整的非叶子节点) => i=1 => 调整结果：4,9,8,5,6
     * 如果再次调用adjust => 传入i=0,结果变为{9,6,8,5,4}
     *
     * @param arr 待调整数组
     * @param i 表示非叶子节点在数组中的索引
     * @param length 表示对多少个元素进行调整，length是指逐渐的减少
     */
    public static void adjustHeap(int[] arr,int i,int length){
        //注意：这个 i= arr.length/2 -1,也就是说已经定位到最后一个非叶子节点了，然后下面的操作都是以此点开始操作
        int temp=arr[i]; //先取出当前元素的值，保存在临时变量
        //开始调整
        for (int k = i*2+1; k < length; k=k*2+1) { //k=i*2+1,是i节点的左子节点
            if(k+1<length && arr[k]<arr[k+1]){    //说明左子节点的值<右子节点的值
                k++; //k指向右子节点
            }
            if(arr[k]>temp){//子节点大于父节点，需要交换
                arr[i]=arr[k];
                i=k;//把较大的值，赋给当前节点，让i指向k，继续循环比较
            }else{
                break;//
            }
        }

        //当for循环结束后，我们已经将以i为父节点的树的最大值，放在了最顶上（局部）
        arr[i]=temp; //将temp值放到调整后的位置
    }
}
```



### 排序算法对比

| 排序算法 | 平均时间复杂度 |  最好情况   |  最坏情况   | 空间复杂度 | 排序方式  | 稳定性 |
| :------: | :------------: | :---------: | :---------: | :--------: | :-------: | :----: |
| 冒泡排序 |     O(n2)      |    O(n)     |    O(n2)    |    O(1)    | In-place  |  稳定  |
| 选择排序 |     O(n2)      |    O(n2)    |    O(n2)    |    O(1)    | In-place  | 不稳定 |
| 插入排序 |     O(n2)      |    O(n)     |    O(n2)    |    O(1)    | In-place  |  稳定  |
| 希尔排序 |   O(n log n)   | O(n log2 n) | O(n log2 n) |    O(1)    | In-place  | 不稳定 |
| 归并排序 |   O(n log n)   | O(n log n)  | O(n log n)  |    O(n)    | Out-place |  稳定  |
| 快速排序 |   O(n log n)   | O(n log n)  |    O(n2)    |  O(log n)  | In-place  | 不稳定 |
|  堆排序  |   O(n log n)   | O(n log n)  | O(n log n)  |    O(1)    | In-place  | 不稳定 |
| 计数排序 |    O(n + k)    |  O(n + k)   |  O(n + k)   |    O(k)    | Out-place |  稳定  |
|  桶排序  |    O(n + k)    |  O(n + k)   |    O(n2)    |  O(n + k)  | Out-place |  稳定  |
| 基数排序 |    O(n * k)    |  O(n * k)   |  O(n * k)   |  O(n + k)  | Out-place |  稳定  |

相关术语解释：

> - 稳定：如果 a 原本在 b 前面，而 a=b，排序之后，a 仍然在 b 的前面
> - 不稳定：不满足稳定定义
> - 内排序（In-place）：所有排序操作都在内存中完成
> - 外排序（Out-place）：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。
> - 时间复杂度：一个算法执行所耗费的时间
> - 空间复杂度：运行完一个程序所需内存的大小
> - n：数据规模
> - k：「桶」的个数
> - In-place：不占用额外内存
> - Out-place：占用额外内存





## 查找算法



### 顺序（线性）查找

```java
package search;

public class SeqSearch {
    public static void main(String[] args) {
        int[] arr={1,9,11,-1,34,89};//无序序列
        int index=seqSearch(arr,11);
        if(index==-1){
            System.out.println("没有查找到");
        }else{
            System.out.println("找到，下标为="+index);
        }

    }

    //这里实现的线性查找是找到一个满足条件的值，就返回
    public static int seqSearch(int [] arr, int value){
        //线性查找是逐一比对，发现有相同的值时，返回下标

        for (int i = 0; i < arr.length; i++) {
            if(arr[i]==value){
                return i;
            }
        }
        return -1;
    }
}

```



### 二分查找 / 折半查找

> 只有在一个有序数组（按大小排的），进行二分查找。
>
> 思路分析：
>
> 1.首先确定该数组中间的下标: mid = (left+right)/2
>
> 2.然后让需要查找的数findVal和arr[mid]比较，如果findVal大，则递归向mid右边查找
>
> 
>
> 什么时候结束递归？
>
> 1.找到就结束递归
>
> 2.递归完整个数组，仍然没有findVal，也需要结束递归 当left>right就需要退出

```java
package search;


import java.util.ArrayList;
import java.util.List;

//注意：使用二分查找的前提必须是数组有序
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr={1,8,10,89,1000,1000,100,1000,1234};
        //测试
//        int resIndex=binarySeach(arr,0,arr.length-1,-1);
//        System.out.println("res="+resIndex);

        ArrayList<Integer> resIndexList = binarySearch2(arr, 0,arr.length - 1, 1000);
        System.out.println("resIndexList="+resIndexList);
    }

    /**
     *
     * @param arr
     * @param left 左边索引
     * @param right 右边索引
     * @param findVal 查找的值
     * @return 找到：返回下标；没找到：-1；
     */
    public static int binarySeach(int[] arr,int left,int right,int findVal){

        //当left>right时，说明递归整个数组了，但没有找到
        if(left>right){
            return -1;
        }

        int mid=(left+right)/2;
        int midVal=arr[mid];

        if(findVal>midVal){//向右递归
            return binarySeach(arr,mid+1,right,findVal);
        }else if(findVal<midVal){//向左递归
            return binarySeach(arr,left,mid-1,findVal);
        }else{
            return mid;
        }

    }

    //完成找到所有相同的数值
    //TODO:有问题
    /**
     * 思路：
     * 1.在找到mid值是，不要马上返回
     * 2.向mid索引值的左边扫描，将所有满足查找值的下标，加入到一个集合中
     * 3.向mid索引值的右边扫描，将所有满足查找值的下标，加入到一个集合中
     * 4.返回集合
     */
    public static ArrayList<Integer> binarySearch2(int[] arr,int left,int right,int findVal){

        //当left>right时，说明递归整个数组了，但没有找到
        if(left>right){
            return new ArrayList<Integer>();
        }

        int mid=(left+right)/2;
        int midVal=arr[mid];

        if(findVal>midVal){//向右递归
            return binarySearch2(arr,mid+1,right,findVal);
        }else if(findVal<midVal){//向左递归
            return binarySearch2(arr,left,mid-1,findVal);
        }else{
            ArrayList<Integer> resIndexlist = new ArrayList<>();
            //向左扫描
            int temp=mid-1;
            while(true){
                if(temp<0||arr[temp]!=findVal){//退出
                    break;
                }
                //否则，就temp 放入到resIndexlist
                resIndexlist.add(temp);
                temp-=1;//temp左移动
            }
            resIndexlist.add(mid);


            //向右边扫描
            temp=mid+1;
            while(true){
                if(temp>arr.length-1||arr[temp]!=findVal){//退出
                    break;
                }
                //否则，就temp 放入到resIndexlist
                resIndexlist.add(temp);
                temp+=1;//temp右移动
            }
//            resIndexlist.add(temp);

            return resIndexlist;
        }

    }
}
```



### 插值查找

> 类似于二分查找，不同在将 mid -> 改为自适应：
>
> ​	midIndex = low + ( high - low ) * ( key-arr[ low ] ) / ( arr[ high ] - arr[ low ] )  插值索引
>
> key: 待查找的值
>
> 
>
> 注意事项：
>
> ​	数组分布不均匀的情况下，该方法不一定比折半查找要好。

```java
package search;

import java.util.Arrays;

public class InsertValueSearch {
    public static void main(String[] args) {
//

        int[] arr={1,8,10,89,1000,1000,100,1000,1234};
        int index=insertValueSearch(arr,0,arr.length-1,1234);
//        System.out.println("index = " + index);
        System.out.println("=============================");
        int b_index = binarySearch(arr, 0, arr.length - 1, 1234);
//        System.out.println();
    }

    //编写插值查找算法

    /**
     *
     * @param arr 有序数组
     * @param left 左边索引
     * @param right 右边索引
     * @param findVal 查找的值
     * @return 如果找到返回对应下标，没找到返回-1
     */
    public static int insertValueSearch(int[] arr,int left,int right,int findVal){

        System.out.println("插值查找次被调用");
        //注意：后面两个条件findVal<arr[0]||findVal>arr[arr.length-1] 必须需要，否则，可能越界
        if(left>right||findVal<arr[0]||findVal>arr[arr.length-1]){
            return -1;
        }
        //求出mid
        int mid=left+(right-left)*(findVal-arr[left])/(arr[right]-arr[left]);
        int midVal=arr[mid];

        if(findVal>midVal){
            //应该向右递归
            insertValueSearch(arr,mid+1,right,findVal);
        }else if(findVal<midVal){
            insertValueSearch(arr,left,mid-1,findVal);
        }

        return mid;
    }

    public static int binarySearch(int[] arr,int left,int right,int findVal){
        System.out.println("二分查找被调用");
        //当left>right时，说明递归整个数组了，但没有找到
        if(left>right){
            return -1;
        }

        int mid=(left+right)/2;
        int midVal=arr[mid];

        if(findVal>midVal){//向右递归
            return binarySearch(arr,mid+1,right,findVal);
        }else if(findVal<midVal){//向左递归
            return binarySearch(arr,left,mid-1,findVal);
        }else{
            return mid;
        }

    }
}
```





### 斐波那契查找

> 黄金分割法：
>
> ​	与前面两种相似，也是改变mid位置，mid = low + F(k-1) -1
>
> **F(k-1) -1**理解: k -> 第几个元素
>
> ​	**F[k] = F[k-1] + F[k-2]**  等价于，下面
>
> ​	**F[k] -1 = ( F[k-1]-1 ) + ( F[k-2] -1 ) +1**
>
> ​	所以：mid=low + F(k-1) -1
>
> ​	(可以想象low=0的时候)
>
> 
>
> 注意：
>
> ​	数组的长度 n 并不一定刚好等于 F[k]-1，所以需要将原来长度增至 F[k] -1，代码示例：
>
> ​	while ( n > fib(k) -1 ){ 	//直到 n <= fib(k) -1
>
> ​		k++; 
>
> ​	}

```java
package search;

import java.util.Arrays;

public class FibonacciSearch {

    public static int maxSize=20;
    public static void main(String[] args) {
        int[] arr={1,8,10,89,1000,1234};

        int index = fibSearch(arr, 1000);
        System.out.println("index = " + index);
    }

    //因为后面我们mid=low+F(k-1)-1,需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列
    public static int[] fib(){
        int[] f=new int[maxSize];
        f[0]=1;
        f[1]=1;
        for (int i = 2; i < maxSize; i++) {
            f[i]=f[i-1] +f[i-2];
        }
        return f;
    }

    //斐波那契查找算法
    //用非递归的方式
    /**
     *
     * @param a 有序数组
     * @param key 需要查找的值
     * @return 返回对应下标，如果没有返回-1
     */
    public static int fibSearch(int[] a,int key){
        int low=0;
        int high=a.length-1;
        int k=0; //表示斐波那契分割数值的下标
        int mid=0; //存放mid值
        int f[]=fib();//获取到斐波那契数列

        //获取到斐波那契分割数值的下标
        while(high>f[k]-1){
            k++;
        }

        //因为f[k]值可能大于数组的长度，因此我们需要使用Arrays类，构造一个新的数组，并指向a
        int[] temp= Arrays.copyOf(a,f[k]);//f[k]是这个temp数组的长度，空白的值使用0填充
        //但我们需要将补充的数，用元组最后的数进行填充
        //举例：
        //temp={1,8,1,89,1000,1234,0,0,0} => {1,8,1,89,1000,1234,1234,1234,1234}
        for (int i = high+1; i < temp.length; i++) {
            temp[i]=a[high];
        }
        //使用while循环，找到key的下标
        while(low<=high){//只要这个条件满足，就可以一直找
            mid=low+f[k-1]-1;
            if(key<temp[mid]){ //说明我们应该继续向数组的前面查找（左边）
                high=mid-1;
                //1.全部的元素=前面的元素+后面的元素
                //2.f[k]=f[k-1]+f[k-2]
                //因为前面有f[k-1]个元素，所以可以继续拆分f[k-1]=f[k-2]+f[k-3]
                //即在f[k-1]的前面继续查找 k--
                //即下次循环mid=f[k-1-1]-1
                k--;
            }else if(key>temp[mid]){ //我们应该继续向数组的后面查找（右边）
                low=mid+1;
                //1.全部的元素=前面的元素+后面的元素
                //2.f[k]=f[k-1]+f[k-2]
                //3.因为后面我们有f[k-2]个元素,所以可以继续拆分f[k-1]=f[k-3]+f[k-4]
                //4.即在f[k-2]的前面进行查找k-=2
                //5.即下次循环mid=f[k-1-2]-1
                k-=2;
            } else{ //找到
                //需要确定，返回的是哪个下标
                if(mid<=high){
                    return mid;
                }else{
                    return high;
                }
            }
        }
        return -1;
    }
}
```





## 哈希表

非线性结构

> 散列（hash table）：根据关键码值（key value）-> 可以直接直接进行访问的数据结构。
>
> ​	通过**把关键码值映射到**表中一个位置来访问记录，以加快查找的速度，这个**映射函数**叫做**散列函数**。存放记录的数组叫做**散列表**。
>
> 哈希表可以：数组+链表 or 数组+二叉树

<img src="C:\Users\TIAN Yixin\AppData\Roaming\Typora\typora-user-images\image-20230215145458403.png" alt="image-20230215145458403" style="zoom:67%;" />

> 以题示例，使用哈希表来管理雇员信息：
>
> ​	在数组里存放的值，指向一条链表，链表里每一个元素指向下一个。

```java
package hash_table.hash_table;


//表示一个雇员
public class Emp {
    public int id;
    public String name;
    public Emp next; //next默认为空

    public Emp(int id,String name){
        super();
        this.id=id;
        this.name=name;
    }
}

===================================================================================================================
    
    package hash_table.hash_table;


//表示链表，链表是保存数据
public class EmpLinkedList {
    //头指针，指向第一个雇员，因此我们这个链表的head，是直接指向第一个Emp
    private Emp head; //默认null

    //添加雇员到链表,说明：
    //1.假定当添加雇员时，id是自增长，即id的分配总是从小到大
    //因此将该雇员直接加入到本链表的最后即可
    public void add(Emp emp){
        //如果是添加第一个雇员
        if(head==null){
            head=emp;
            return;
        }

        //如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后
        Emp curEmp=head; //辅助指针
        while(true){
            if(curEmp.next==null){ //找到最后一个节点为止
                break;
            }
            curEmp=curEmp.next;
        }

        //退出时直接将emp加到最后即可
        curEmp.next=emp;
    }

    //遍历链表的雇员信息
    public void list(int no){
        if(head==null){
            System.out.println("第 "+(no+1)+" 当前链表为空");
            return;
        }
        System.out.print("第 "+(no+1)+" 链表信息为:");
        Emp curEmp=head;
        while(true){
            System.out.printf("=> id=%d name=%s \t",curEmp.id,curEmp.name);
            if(curEmp.next==null){//说明curEmp已经是最后节点
                break;
            }
            curEmp=curEmp.next; //后移遍历
        }
        System.out.println();
    }

    //根据id查找雇员
    //如果查找到，就返回Emp,如果没找到，就返回null
    public Emp findById(int id){
        //判断链表是否为空
        if(head==null){
            System.out.println("链表为空");
            return null;
        }
        Emp curEmp=head;
        while(true){
            if(curEmp.id==id){
                break;//这时curEmp就指向要查找的雇员
            }
           //退出
           if(curEmp.next==null){//说明遍历当前链表没有找到该雇员
               curEmp=null;
               break;
           }
            curEmp=curEmp.next;//以后
        }
        return curEmp;
    }

}

===================================================================================================================
    
    package hash_table.hash_table;


//用来管理多条链表
public class HashTable {
    private EmpLinkedList[] empLinkedArray;
    private int size; //表示共有多少条链表

    //构造器
    public HashTable(int size){
        this.size=size;
        //初始化empLinkedArray
        empLinkedArray =new EmpLinkedList[size];
        //这时不要忘了分别初始化每个链表
        for (int i = 0; i < size; i++) {
            empLinkedArray[i]=new EmpLinkedList();
        }
    }


    //添加雇员
    public void add(Emp emp){
        //根据员工的id,得到该员工应当添加到哪条链表
        int empLinkedListNO = hashFun(emp.id);
        //将emp添加到对应的链表中
        empLinkedArray[empLinkedListNO].add(emp);
    }


    //遍历所有的链表，遍历hash表
    public void list(){
        for (int i = 0; i < size; i++) {
            empLinkedArray[i].list(i);
        }

    }

    //根据输入的id查找雇员
    public void findById(int id){
        //使用散列函数确定到哪条链表查找
        int empLinkedListNO = hashFun(id);
        Emp emp=empLinkedArray[empLinkedListNO].findById(id);
        if(emp!=null){//找到
            System.out.printf("在第%d条链表中找到 雇员id=%d\n",empLinkedListNO+1,id);
        }else{
            System.out.println("在哈希表中没有找到该雇员");
        }
    }


    //编写散列函数，使用一个简单取模法i
    public int hashFun(int id){
        return id%size;
    }
}

===================================================================================================================
package hash_table.hash_table;


import java.util.Scanner;

public class Test {
    public static void main(String[] args) {

        //创建哈希表
        HashTable hashTab = new HashTable(7);

        //菜单：
        String key="";
        Scanner sc = new Scanner(System.in);
        while(true) {
            System.out.println("add:添加");
            System.out.println("find:查找");
            System.out.println("list:显示");
            System.out.println("exit:退出");

            key=sc.next();
            switch (key){
                case "add":
                    System.out.println("输入id");
                    int id=sc.nextInt();
                    System.out.println("输入name");
                    String name=sc.next();

                    //创建雇员
                    Emp emp = new Emp(id, name);
                    hashTab.add(emp);
                    break;
                case "find":
                    System.out.println("请输入要查找的id");
                    id = sc.nextInt();
                    hashTab.findById(id);
                    break;
                case "list":
                    hashTab.list();
                    break;
                case "exit":
                    sc.close();
                    System.exit(0);
                    break;
                default:
                    break;
            }
        }
    }
}
```





## 树

> 为什么需要树？在内存里，将数据存储起来：
>
> （1）数组：可以通过下标直接查找，速度比较快。但是插入的时候，需要整体移动，效率较低。（数组事先分配空间，扩容需要在底层创建一个新数组，需要将原来的值拷贝到数组，并插入）。
>
> （2）链表：插入不需要整体移动，只需要首位指向就好。但是检索时，速度依然很低，得从头节点进行遍历。
>
> （3）树：能够提高存储，读取效率，如果用二叉排序树，也可以保证检索速度。
>
> 
>
> 以二叉排序树来存储数据的效率：
>
> （1）查：比较与根节点的大小；
>
> （2）增：
>
> （3）删



### 常用术语

> 根节点，
>
> 节点（对象），
>
> 叶子节点（没有子节点的节点），
>
> 节点的权（节点值），
>
> 路径（从root节点找到该节点的路线），
>
> 层，
>
> 树的高度（最大层数），
>
> ...

### 二叉树

​	每个节点最多只能有两个子节点的树 -> 二叉树，分为左节点和右节点

#### 满二叉树

> （1）**所有叶子节点在同一层**（最后一层）
>
> （2）节点总数=2^n-1，n为层数

#### 完全二叉树

> （1）所有叶子节点在最后一层或倒数第二层
>
> （2）**左边叶子节点**和**右边叶子节点**连续
>
> *如果不连续就不叫完全二叉树了

#### 遍历

前序遍历

> (1)**父节点**  (2)左子树  (3)右子树



中序遍历

> (1)左子树  (2)**父节点**  (3)右子树



后序遍历

> (1)左子树  (2)右子树  (3)**父节点**  

```java
//节点
package tree;


//创建HeroNode节点
public class HeroNode {
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no,String name){
        this.no=no;
        this.name=name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }


    //编写前序遍历
    public void preOrder(){
        System.out.println(this);//先输出父节点
        //递归向左子树
        if(this.left!=null){
            this.left.preOrder();
        }

        if(this.right!=null){
            this.right.preOrder();
        }
    }
    //编写中序遍历
    public void infixOrder(){
        //递归向左
        if(this.left!=null){
            this.left.infixOrder();
        }

        System.out.println(this);

        if(this.right!=null){
            this.right.infixOrder();
        }
    }

    //编写后序遍历
    public void postOrder(){
        if(this.left!=null){
            this.left.postOrder();
        }

        if(this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);
    }
}

===================================================================================================================
    package tree;

public class BinaryTree {
    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }
    //前序遍历
    public void preOrder(){
        if(this.root!=null){
            this.root.preOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //中序遍历
    public void infixOrder(){
        if(this.root!=null){
            this.root.infixOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }
    //后序遍历
    public void postOrder(){
        if(this.root!=null){
            this.root.postOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }

}
===================================================================================================================
package tree;

public class Test {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();

        HeroNode root = new HeroNode(1, "Tom");
        HeroNode node2 = new HeroNode(2, "Mary");
        HeroNode node3 = new HeroNode(3, "Vivi");
        HeroNode node4 = new HeroNode(4, "Cici");
        HeroNode node5 = new HeroNode(5, "Coco");

        //说明，我们先手动创建该二叉树，后面学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        binaryTree.setRoot(root);
        //测试：
        System.out.println("前序遍历"); //1,2,3,5,4
        binaryTree.preOrder();
        System.out.println("===================");
        System.out.println("中序遍历"); //2,1,5,3,4
        binaryTree.infixOrder();
        System.out.println("===================");
        System.out.println("后序遍历"); //2,5,4,3,1
        binaryTree.postOrder();

    }
}
```





#### 查找

> **前序查找**：
>
> 1.先判断当前节点的no是否等于要查找的，如果相等，则返回当前节点
>
> 2.如果不等，则判断当前节点的左子节点是否为空，不为空，则递归前序查找
>
> 3.如果左递归前序查找找到节点则返回，否则，判断右子节点是否为空，不为空，则继续向右递归前序查找
>
> 
>
> **中序查找**：
>
> 1.先判断当前节点的左子节点是否为空，如果不为空，则递归前序查找
>
> 2.如果找到，则返回，否则，跟当前节点比较，如过不是当前节点，则继续进行右递归的中序查找
>
> 3.如果右递归中序查找，找到就返回，否则返回null
>
> 
>
> **后序查找**：
>
> 1.先判断当前节点的左子节点是否为空，如果不为空，则递归后序查找
>
> 2.如果找到，则返回，否则，跟当前右子节点比较，如过不为空，则继续进行右递归的后序查找
>
> 3.跟当前节点进行比较，找到就返回，否则返回null

```java
//写在上面部分的HeroNode里    

    /**
     *
     * @param no 查找no
     * @return 找到：Node,没找到：null
     */
    //前序遍历查找
    public HeroNode preOrdersearch(int no){
        System.out.println("前序遍历查找");
        //比较当前节点
        if(this.no==no){
            return this;
        }
        //1.则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找
        //2.如果左递归前序查找，找到节点，则返回
        HeroNode resNode=null;
        if(this.left!=null){
            resNode=this.left.preOrdersearch(no);
        }
        if(resNode!=null){//说明我们左子树找到了
            return resNode;
        }
        //如果左递归前序查找找到节点则返回，否则，判断右子节点是否为空，不为空，则继续向右递归前序查找
        if(this.right!=null){
            resNode=this.right.preOrdersearch(no);
        }
        return resNode;
    }


    //中序遍历查找
    public HeroNode infixOrdersearch(int no){

        HeroNode res=null;
        if(this.left!=null){
          res=this.left.infixOrdersearch(no);
        }
        if(res!=null){
            return res;
        }
        System.out.println("中序遍历查找");
        if(this.no==no){
            return this;
        }
        if(this.right!=null){
            res=this.right.infixOrdersearch(no);
        }
        return res;
    }

    //后序遍历查找
    public HeroNode postOrdersearch(int no){
        HeroNode res=null;
        if(this.left!=null){
            res=this.left.postOrdersearch(no);
        }
        if(res!=null){
            return res;
        }
        if(this.right!=null){
            res=this.right.postOrdersearch(no);
        }
        if(res!=null){
            return res;
        }
        System.out.println("后序遍历查找");
        if(this.no==no){
            return this;
        }
        return res;
    }
```

#### 删除

> 如果删除的节点的是叶子节点，则删除该节点
>
> 如果删除的节点是非叶子节点，则删除此子树
>
> 
>
> 思路：
>
> 6.先考虑只有一个root节点，则将二叉树置空
>
> 1.因为我们的二叉树是单向的（只能向后找，无法向前找），所以我们判断当前节点的子节点是否需要删除，而不是当前节点
>
> 2.如果当前节点的左子节点不为空，并且左子节点就是需要删除的节点，则将this.left置空，并且返回
>
> 3.如果当前节点的右子节点不为空，并且右子节点就是需要删除的节点，则将this.right置空，并且返回
>
> 4.如果第2步和第3步也没有删除节点，那我们需要向左进行递归删除
>
> 5.如果4没有删除，则需要向右进行递归删除
>
> 
>
> （递归是到最下面，一层一层往上走的）

```java
//写在上面部分的HeroNode里        

//递归删除节点
    //如果删除的节点的是叶子节点，则删除该节点
    //如果删除的节点是非叶子节点，则删除此子树
    //删除思路：
    /**
     * 6.先考虑只有一个root节点，则将二叉树置空(写在binaryTree那个类里)
     * 1.因为我们的二叉树是单向的（只能向后找，无法向前找），所以我们判断当前节点的子节点是否需要删除，而不是当前节点
     * 2.如果当前节点的左子节点不为空，并且左子节点就是需要删除的节点，则将this.left置空，并且返回
     * 3.如果当前节点的右子节点不为空，并且右子节点就是需要删除的节点，则将this.right置空，并且返回
     * 4.如果第2步和第3步也没有删除节点，那我们需要向左进行递归删除
     * 5.如果4没有删除，则需要向右进行递归删除
     */
    
    public void delNode(int no){
        if(this.left!=null && this.left.no==no){
            this.left=null;
            return;
        }
        if(this.right!=null && this.right.no ==no){
            this.right=null;
            return;
        }
        if(this.left!=null){
            this.left.delNode(no);
        }
        if(this.right!=null){
            this.right.delNode(no);
        }
    }
===================================================================================================================
   //写在上面部分的binaryTree里    
        public void delNode(int no){
        if(this.root!=null){
            //如果只有一个root节点，这里要立即判断
            if(root.getNo()==no){
                root=null;
            }else{
                root.delNode(no);
            }
        }else{
            System.out.println("空树，不能删除");
        }
    }
```





### 顺序存储二叉树

​	从存储方式来看，**数组和树的存储方式可以互相转换**。

​	**堆排序会用到顺序存储二叉树**

<img src="C:\Users\TIAN Yixin\Desktop\20210320130321986.png" alt="20210320130321986" style="zoom:67%;" />

> 要求：
>
> 1. 二叉树的节点，要以数组的方式存放 arr :[1,2,3,4,5,6,7]
> 2. 在遍历数组arr时，仍然以前序、中序、后序遍历的方式完成节点的遍历
>
> 上述这种要求，就是顺序存储二叉树。
>
> 
>
> **特点**：
>
> 1.顺序二叉树通常只考虑完全二叉树
>
> 2.第n个元素（下标）的左子节点为 2*n+1 （下标）
>
> 3.第n个元素（下标）的右子节点为 2*n+2 （下标）
>
> 4.第n个元素（下标）的父节点为 （n-1)/2 （下标）

```java
package tree.arrayBinaryTree;

import java.util.ArrayList;

public class ArrBinary {
    private int[] arr; //存储数据节点的数组

    public ArrBinary(int[] arr){
        this.arr=arr;
    }

    //重载preOrder
    public void preOrder(){
        this.preOrder(0);
    }

    //编写一个方法，完成顺序存储二叉树的前序遍历
    public void preOrder(int index){//index也就是数组的下标
        //如果数组为空，或者arr.length=0
        if(arr==null||arr.length==0){
            System.out.println("数组为空，不能按照二叉树前序遍历");
            return;
        }
        //输出当前元素
        System.out.println(arr[index]);
        if(index*2+1<arr.length){
            preOrder(2*index+1);
        }
        //向右递归
        if((index*2+2)<arr.length){
            preOrder(2*index+2);
        }
    }
}
===================================================================================================================
    package tree.arrayBinaryTree;

public class Test {
    public static void main(String[] args) {
        int[] arr={1,2,3,4,5,6,7};
        ArrBinary arrBinaryTree = new ArrBinary(arr);
        arrBinaryTree.preOrder(0);//1,2,4,5,3,6,7
    }
}
```





### 线索化二叉树

> 对于一个有n个节点的二叉链表，它含有 n+1 （也就是 2n-(n-1)=n+1 ）个空指针域。
>
> 如果我们想充分利用这些空指针域，那么就会形成线索二叉树：
>
> （1）利用空指针域，存放该节点在**前序遍历次序的前驱和后继**（形成”线索“）-> **前序二叉树** 
>
> （2）利用空指针域，存放该节点在**中序遍历次序的前驱和后继**（形成”线索“）-> **中序二叉树** 
>
> （3）利用空指针域，存放该节点在**后序遍历次序的前驱和后继**（形成”线索“）-> **后序二叉树** 
>
> 
>
> 这里有存在个情况就是 [ 说明 ]：
>
> 1. left 指向不一定是前驱节点，可能是左子树；
> 2. right 指向不一定是后继节点，可能是右子树。



遍历

> 因为线索化后，左右指针都变了，所以之前的遍历方式不行了。
>

```java
package tree.threadBinaryTree;

public class HeroNode {
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    private int leftType;//如果指向左子树，则为0；否则为1（前驱节点）
    private int rightType;//如果指向右子树，则为0；否则为1（后继节点）

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    public HeroNode(int no, String name){
        this.no=no;
        this.name=name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }


    //编写前序遍历
    public void preOrder(){
        System.out.println(this);//先输出父节点
        //递归向左子树
        if(this.left!=null){
            this.left.preOrder();
        }

        if(this.right!=null){
            this.right.preOrder();
        }
    }
    //编写中序遍历
    public void infixOrder(){
        //递归向左
        if(this.left!=null){
            this.left.infixOrder();
        }

        System.out.println(this);

        if(this.right!=null){
            this.right.infixOrder();
        }
    }

    //编写后序遍历
    public void postOrder(){
        if(this.left!=null){
            this.left.postOrder();
        }

        if(this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);
    }

    //前序遍历查找
    public HeroNode preOrdersearch(int no){
        System.out.println("前序遍历查找");
        //比较当前节点
        if(this.no==no){
            return this;
        }
        //1.则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找
        //2.如果左递归前序查找，找到节点，则返回
        HeroNode resNode=null;
        if(this.left!=null){
            resNode=this.left.preOrdersearch(no);
        }
        if(resNode!=null){//说明我们左子树找到了
            return resNode;
        }
        //如果左递归前序查找找到节点则返回，否则，判断右子节点是否为空，不为空，则继续向右递归前序查找
        if(this.right!=null){
            resNode=this.right.preOrdersearch(no);
        }
        return resNode;
    }


    //中序遍历查找
    public HeroNode infixOrdersearch(int no){

        HeroNode res=null;
        if(this.left!=null){
            res=this.left.infixOrdersearch(no);
        }
        if(res!=null){
            return res;
        }
        System.out.println("中序遍历查找");
        if(this.no==no){
            return this;
        }
        if(this.right!=null){
            res=this.right.infixOrdersearch(no);
        }
        return res;
    }

    //后序遍历查找
    public HeroNode postOrdersearch(int no){
        HeroNode res=null;
        if(this.left!=null){
            res=this.left.postOrdersearch(no);
        }
        if(res!=null){
            return res;
        }
        if(this.right!=null){
            res=this.right.postOrdersearch(no);
        }
        if(res!=null){
            return res;
        }
        System.out.println("后序遍历查找");
        if(this.no==no){
            return this;
        }
        return res;
    }

    public void delNode(int no){
        if(this.left!=null && this.left.no==no){
            this.left=null;
            return;
        }
        if(this.right!=null && this.right.no ==no){
            this.right=null;
            return;
        }
        if(this.left!=null){
            this.left.delNode(no);
        }
        if(this.right!=null){
            this.right.delNode(no);
        }
    }
}
===================================================================================================================
    package tree.threadBinaryTree;


//线索化二叉树
public class ThreadBinaryTree {
    private HeroNode root;

    //pre在递归进行线索化，总是保留前一个节点
    private HeroNode pre=null;//为了实现线索化，需要创建一个指向当前节点的前驱节点指针

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    //重载线索化方法
    public void threadedNode(){
        threadedNode(root);
    }

    //遍历线索化二叉树的方法
    public void threadedList(){
        //定义一个变量，存储当前遍历的节点，从root开始
        HeroNode node=root;
        while(node!=null){
            //循环的找到LeftType==1的节点，第一个找到8
            //后面随着遍历而变化，因为当leftType=1时
            while(node.getLeftType()==0){
                node=node.getLeft();
            }
            //打印当前节点
            System.out.println(node);
            //如果当前节点的右指针指向的是后继节点，就一直输出
            while(node.getRightType()==1){
                //获取到当前节点的后继节点
                node = node.getRight();
                System.out.println(node);
            }

            //替换遍历的节点
            node=node.getRight();
        }
    }

    //编写对二叉树进行中序线索化的方法（2,1,5,3,4）

    /**
     * @param node 当前需要线索化的节点
     */
    public void threadedNode(HeroNode node){
        if(node==null){
            return;
        }

        //1.先线索化左子树
        threadedNode(node.getLeft());
        //2.再线索化当前子树
        //先处理当前节点的前驱节点

        if(node.getLeft()==null){
            //让当前节点的左指针指向前驱节点
            node.setLeft(pre);//以2节点来理解，2节点.left=null，2节点的type=1
            //修改当前节点的左指针的类型
            node.setLeftType(1);
        }

        //处理后继节点
        if(pre!=null&&pre.getRight()==null){
            //让前驱节点的右指针指向当前节点
            pre.setRight(node);
            //修改前驱节点的右指针类型
            pre.setLeftType(1);
        }
        //!!!
        //每处理一个节点后，让当前节点是下一个节点的前驱节点
        pre=node;

        //3.最后线索化右子树
        threadedNode(node.getRight());
    }

    //前序遍历
    public void preOrder(){
        if(this.root!=null){
            this.root.preOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //中序遍历
    public void infixOrder(){
        if(this.root!=null){
            this.root.infixOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }
    //后序遍历
    public void postOrder(){
        if(this.root!=null){
            this.root.postOrder();
        }else{
            System.out.println("二叉树为空，无法遍历");
        }
    }

    //前序遍历查找
    public HeroNode preOrderSearch(int no){
        if(root!=null){
            return root.preOrdersearch(no);
        }else{
            return null;
        }
    }

    //中序遍历查找
    public HeroNode infixOrderSearch(int no){
        if(root!=null){
            return root.infixOrdersearch(no);
        }else{
            return null;
        }
    }

    //后序遍历查找
    public HeroNode postOrderSearch(int no){
        if(root!=null){
            return root.postOrdersearch(no);
        }else{
            return null;
        }
    }

    //删除
    public void delNode(int no){
        if(this.root!=null){
            //如果只有一个root节点，这里要立即判断
            if(root.getNo()==no){
                root=null;
            }else{
                root.delNode(no);
            }
        }else{
            System.out.println("空树，不能删除");
        }
    }
}
===================================================================================================================
    package tree.threadBinaryTree;

public class Test {
    public static void main(String[] args) {
        //测试中序线索二叉树的功能
        HeroNode root = new HeroNode(1, "Tom");
        HeroNode node2 = new HeroNode(3, "Jack");
        HeroNode node3 = new HeroNode(6, "Smith");
        HeroNode node4 = new HeroNode(8, "Mary");
        HeroNode node5 = new HeroNode(10, "King");
        HeroNode node6 = new HeroNode(14,"Dim");

        //创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        //线索化
        ThreadBinaryTree threadBinaryTree = new ThreadBinaryTree();
        threadBinaryTree.setRoot(root);

        threadBinaryTree.threadedNode();

        //测试以10为例
        HeroNode leftNode = node4.getLeft();
        System.out.println("8号节点的leftNode = " + leftNode); //3
        System.out.println(node4.getLeftType());
        HeroNode rightNode = node4.getRight();
        System.out.println("8号节点的rightNode = " + rightNode); //1
        System.out.println(node4.getRightType());


        //遍历测试
        System.out.println("遍历测试:");
        //TODO:有问题
//        threadBinaryTree.threadedList(); //8,3,10,1,14,6
    }
}

```



### 堆排序

二叉树的应用，详见 **排序算法 -> 堆排序**





### 赫夫曼树

> 给定n个叶子节点，with n个权值，构造一个二叉树，若该树的带权路径长度（wpl）达到最小 -> 最优二叉树（赫夫曼树）
>
> 
>
> 路径：从一个节点往下可达的孩子或孙子节点的通路
>
> 路径的长度：就是看有多少层数（分支的数目）
>
> 节点的权：节点所赋的值
>
> 带权路径的长度：路径长度与该节点的权的乘积
>
> 树的带权路径长度（wpl）：所有叶子节点的带权路径长度之和，权值越大的节点离根节点越近的二叉树才是最优二叉树，wpl最小的就是赫夫曼树
>
> 
>
> 思路分析：（如何构建一颗赫夫曼树）
>
> 1.从小到大，对数列进行排序；
>
> 2.取权值最小的两个节点，构建成一颗二叉树（它两是子节点，他们的父节点权值就是它两的和）
>
> 3.每次选择值最小的两个节点（包括2里面提到的父节点的值），然后像2一样组合
>
> 4.重复1，2，3，4

```java
package tree.huffmantree;

//创建节点类
//为了让Node对象支持排序Collection
//让node实现Comparable接口
public class Node implements Comparable<Node>{
    int value; //节点权值
    Node left;  //指向左子节点
    Node Right;  //指向右子节点

    public Node(int value){
        this.value=value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        //从小到大进行排序
        return this.value-o.value;
    }

    //前序遍历
    public void preOrder(){
        System.out.println(this);
        if(this.left!=null){
            this.left.preOrder();
        }
        if(this.Right!=null){
            this.Right.preOrder();
        }
    }
}
===================================================================================================================
    package tree.huffmantree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class HaffmanTree {
    public static void main(String[] args) {
        int[] arr={13,7,8,3,29,6,1};
        Node root=createHuffmanTree(arr);

        //测试
        preOrder(root); //67,29,38,15,7,8,23,10,4,1,3,6,13
    }

    //编写前序遍历的方法
    public static void preOrder(Node root){
        if(root!=null){
            root.preOrder();
        }else{
            System.out.println("是空树，不能遍历");
        }
    }

    //创建赫夫曼树的方法
    public static Node createHuffmanTree(int[] arr){
        //第一步，为了操作方便
        //1.遍历arr数组
        //2.将arr的每个元素构建成一个Node
        //3.将Node放入到ArrayList中
        List<Node> nodes = new ArrayList<>();
        for (int value:arr) {
            nodes.add(new Node(value));
        }
        //处理的过程是一个循环的过程
        while(nodes.size()>1) {
            //排序:从小到大
            Collections.sort(nodes);

            //取出根节点权值最小的两颗二叉树
            //1.取出权值最小的节点（我们就认为是一个二叉树）
            Node leftNode = nodes.get(0);
            //2.取出第二小的节点
            Node rightNode = nodes.get(1);

            //3.构建一颗新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.Right = rightNode;

            //4.从arraylist中删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //5.将parent加入nodes
            nodes.add(parent);
        }
        //返回赫夫曼树的root节点
        return nodes.get(0);
    }
}
```





#### 赫夫曼编码

> 是一种编码方式，属于一种程序算法。在电讯通信中的经典应用之一。
>
> 广泛用于数据文件的压缩，其压缩率通常在20%~90%之间。
>
> 是可变字长编码（VLC）的一种。

​		

电讯通信方式：

> **方式一**：**定长编码**。比如一行文字，变成ASCII对应的十进制，再变成二进制进行传输。
>
> **方式二**：**变长编码**。同样一行文字，先对文件中出现的词进行统计，再对出现次数多的词，用少位进行编码。比如 i 出现次数最多，可以用 0 表示 i...。但存在问题：比如字符的编码可能是其他字符编码的前缀。
>
> 字符的编码不是其他字符编码的前缀，符合此要求的编码叫做前缀编码，即不会匹配到重复的编码
>
> **方式三**：**赫夫曼编码**。



赫夫曼编码的原理剖析：

> 1.统计各个字符出现的词数
>
> 2.按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值（1，1，2，2，2，4，4，4，5，5，9）
>
> 3.根据赫夫曼树，给各个字符规定编码（编码：向左为0，向右为1） =>  **前缀编码**！！！！！
>
> 4.按照上面赫夫曼编码，将文字变为对应编码（使用无损压缩）



##### 数据压缩

将 i like like like java do you like a java => 压缩成二进制

> 思路分析：
>
> 1. 构建一个新的节点Node，需要属性 data，weight（比如一共有几个i），left，right
> 2. 得到”i like like like java do you like a java“ 对应的byte[]数组
> 3. 编写一个方法，将准备构建赫夫曼树的Node节点放到list中，形式[Node[date=97('a'),wight=5],Node[date=32,weight=9]
> 4. 可以通过List创建对应的赫夫曼树

```java
package tree.huffmancode;

//创建Node,带数据和权值
public class Node  implements Comparable<Node> {
    Byte data;  //存放数据（字符）本身，比如'a'=> 97  ' '=>32
    int weight; //权值，表示字符出现的次数
    Node left;
    Node right;
    public Node(Byte data,int weight){
        this.data=data;
        this.weight=weight;
    }

    @Override
    public int compareTo(Node o){
        //从小到大
        return this.weight-o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    public void preOrder(){
        System.out.println(this);
        if(this.left!=null){
            this.left.preOrder();
        }
        if(this.right!=null){
            this.right.preOrder();
        }
    }
}
===================================================================================================================
package tree.huffmancode;

import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        String content="i like like like java do you like a java";
        byte[] contentBytes = content.getBytes();
        System.out.println(contentBytes.length); //40

        //分布过程
        /*
        List<Node> nodes = getNodes(contentBytes);
        System.out.println("nodes = " + nodes);
        System.out.println("========================================");
        //测试一把，创建二叉树
        System.out.println("赫夫曼树");
        Node huffmanTreeRoot = createHuffmanTree(nodes);
        System.out.println("前序遍历");
        huffmanTreeRoot.preOrder();
        System.out.println("========================================");

        //测试是否生成了赫夫曼编码
//        getcodes(huffmanTreeRoot,"",stringBuilder);
        Map<Byte, String> huffmanCodes = getcodes(huffmanTreeRoot);
        System.out.println("生成的赫夫曼编码表:"+ huffmanCodes);
        //{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}


        //测试
        byte[] huffmanCodeBytes=zip(contentBytes,huffmanCodes);
        System.out.println("huffmanCodeBytes = " + Arrays.toString(huffmanCodeBytes)); //17个字节
        //[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]

        //发送huffmanCodeBytes 数组*/
        byte[] huffmanCodeBytes = huffmanZip(contentBytes);
        System.out.println("压缩后的结果是："+Arrays.toString(huffmanCodeBytes));//[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
        System.out.println("长度="+huffmanCodeBytes.length);
    }


    private static void preOrder(Node root){//前序遍历的方法
        if(root!=null){
            root.preOrder();
        }else{
            System.out.println("赫夫曼树为空，无法遍历");
        }
    }


    /**
     *
     * @param bytes 接收字节数组
     * @return 返回的就是List形式[Node[date=97('a'),wight=5],Node[date=32,weight=9]]
     */
    private static List<Node> getNodes(byte[] bytes){

        //1.创建一个ArrayList
        ArrayList<Node> nodes=new ArrayList<Node>();

        //遍历bytes,统计每一个byte出现的次数 -> map[key,value]
        Map<Byte, Integer> counts = new HashMap<>();

        for (byte b:bytes) {
            Integer count = counts.get(b);
            if(count==null){//map还没有这个字符数据,第一次
                counts.put(b,1);
            }else{
                counts.put(b,count+1);
            }
        }
        //把每个键值对转成一个Node对象，并加入到nodes集合
        for(Map.Entry<Byte,Integer> entry:counts.entrySet()){//遍历map
            nodes.add(new Node(entry.getKey(),entry.getValue()));
        }
        return nodes;
    }
    
    
    //通过list创建赫夫曼树
    private static Node createHuffmanTree(List<Node> nodes){
        while(nodes.size()>1){
            //排序,从小到大
            Collections.sort(nodes);
            //取出第一颗最小的二叉树
            Node leftNode = nodes.get(0);
            //取出第二颗最小的二叉树
            Node rightNode = nodes.get(1);
            //创建一颗新的二叉树，它的根节点没有data,只有权值
            Node parent=new Node(null,leftNode.weight+rightNode.weight);
            parent.left=leftNode;
            parent.right=rightNode;
            
            //将已经处理的两颗二叉树从nodes删除
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //将新的二叉树加入到nodes
            nodes.add(parent);
        }
        //返回的节点nodes 就是赫夫曼树的根节点
        return nodes.get(0);
    }

    //生成赫夫曼树对应的赫夫曼编码
    //思路：
    //1.将赫夫曼编码表存放在Map<Byte,String> 形式如下：
    //  32 -> 01 , 97(a)->100, 100(d) ->1100 等等 （这个表可能将来不一样，形式相同）
    //2.在生成赫夫曼编码表时，需要不停的去拼接路径，定义一个StringBuilder 存储某个叶子节点的路径
    static Map<Byte,String> huffmanCodes =new HashMap<Byte,String>();
    static StringBuilder stringBuilder=new StringBuilder();

    /**
     * 功能：将传入的node节点的所有叶子节点的赫夫曼编码得到，并放入到huffmanCodes这个集合中
     * @param node 传入root根节点
     * @param code 就是路径这个值，左边为0，右边为1
     * @param stringBuilder 用于拼接路径的
     */
    private static void getcodes(Node node,String code,StringBuilder stringBuilder){
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        //将传入的code传入stringBuilder2
        stringBuilder2.append(code);
        if(node!=null){//如果node==null不处理
            //判断当前node是叶子节点还是非叶子节点
            if(node.data==null){ //非叶子节点
                //递归处理
                //向左递归
                getcodes(node.left,"0",stringBuilder2);
                //向右递归
                getcodes(node.right,"1",stringBuilder2);
            }else{ //说明是一个叶子节点
                //表示找到了某个叶子节点的最后
                huffmanCodes.put(node.data,stringBuilder2.toString());
            }
        }
    }

    //为了调用方便，重载getCodes
    private static Map<Byte,String> getcodes(Node root){
        if(root==null){
            return null;
        }
        //处理root的左子树
        getcodes(root.left,"0",stringBuilder);
        //处理root的右子树
        getcodes(root.right,"1",stringBuilder);
        return huffmanCodes;
    }



    //编写一个方法：将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]

    /**
     *
     * @param bytes 这是原始的字符串对应的byte[]
     * @param huffmanCodes 生成的赫夫曼编码map
     * @return 返回赫夫曼编码处理后的byte[]
     *
     * 举例：String content="i like like like java do you like a java"; =>
     *         byte[] contentBytes = content.getBytes();
     * 返回的是 这个字符串“1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100”
     * 也就是对应的byte[] huffmanCodeBytes,即8位对应一个byte,放入huffmanCodeBytes
     * huffmanCodeBytes[0] =
     * 10101000(补码) => byte [推导 补码->反码（补码减一）（101000111）->原码（符号位不变，其他反码）（11011000）=-88]
     * huffmanCodeBytes[1]=-88
     */
    private static byte[] zip(byte[] bytes,Map<Byte,String> huffmanCodes){
        //这个map是上面这个函数的返回值，返回了一个带有key和value的map,key是字符对应的char值，value是编号01，10，...这样的
        //然后下面这个map.get是取的map里的value的值

        //1.先利用赫夫曼编码表将传进来的byte[]转成赫夫曼编码的字符串
        StringBuilder stringBuilder = new StringBuilder();
        //遍历byte数组
        for (byte b:bytes) {
            stringBuilder.append(huffmanCodes.get(b));
        }
//        System.out.println("stringBuilder = " + stringBuilder);
        //将“1010100010111111..."转成byte[]


        //统计返回byte[] huffmanCodeBytes 长度
        //一句话int len=(stringBuilder.length()+7)/8;

        int len;
        if(stringBuilder.length()%8==0){
            len=stringBuilder.length()/8;
        } else{
            len=stringBuilder.length()/8+1;
        }
        //创建存储压缩后的byte数组
        byte[] huffmanCodeBytes=new byte[len];
        int index=0;
        for (int i = 0; i < stringBuilder.length(); i+=8) { //因为是每8位对应一个byte,所以步长+8
            String strByte;
            if(i+8>stringBuilder.length()) {//不够8位
                strByte = stringBuilder.substring(i); //这个后面不写就是从i开始取，取到最后的意思
            }else{
                strByte = stringBuilder.substring(i, i + 8);
            }
            //将strByte转成一个byte,放入到huffmanCodeBytes
            huffmanCodeBytes[index]=(byte) Integer.parseInt(strByte,2);
            index++;
        }
        return huffmanCodeBytes;
    }


    /**
     *
     * @param bytes 原始字符串对应的字节数组
     * @return  经过赫夫曼编码处理后的字节数组（压缩后的数组）
     */
    //使用一个方法，将前面的方法封装起来，便于我们的调用
    private static byte[] huffmanZip(byte[] bytes){
        List<Node> nodes = getNodes(bytes);
        //根据nodes 创建的赫夫曼树
        Node huffmanTreeRoot = createHuffmanTree(nodes);
        //根据赫夫曼树创建对应的赫夫曼map<值，值对应的赫夫曼编码>
        Map<Byte, String> huffmanCodes = getcodes(huffmanTreeRoot);
        //根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组
        byte[] huffmanCodeBytes=zip(bytes,huffmanCodes);
        return huffmanCodeBytes;
    }
}
```



##### 数据解压

> 前面我们得到了赫夫曼编码和对应的byte[] :[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]，我们现在需要将赫夫曼编码变为原来的字符串“i like like like java do you like a java”。

```java
package tree.huffmancode;

import javax.print.DocFlavor;
import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        String content="i like like like java do you like a java";
        byte[] contentBytes = content.getBytes();
        System.out.println(contentBytes.length); //40

        //分布过程
        /*
        List<Node> nodes = getNodes(contentBytes);
        System.out.println("nodes = " + nodes);
        System.out.println("========================================");
        //测试一把，创建二叉树
        System.out.println("赫夫曼树");
        Node huffmanTreeRoot = createHuffmanTree(nodes);
        System.out.println("前序遍历");
        huffmanTreeRoot.preOrder();
        System.out.println("========================================");

        //测试是否生成了赫夫曼编码
//        getcodes(huffmanTreeRoot,"",stringBuilder);
        Map<Byte, String> huffmanCodes = getcodes(huffmanTreeRoot);
        System.out.println("生成的赫夫曼编码表:"+ huffmanCodes);
        //{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}


        //测试
        byte[] huffmanCodeBytes=zip(contentBytes,huffmanCodes);
        System.out.println("huffmanCodeBytes = " + Arrays.toString(huffmanCodeBytes)); //17个字节
        //[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]

        //发送huffmanCodeBytes 数组*/
        byte[] huffmanCodeBytes = huffmanZip(contentBytes);
        System.out.println("压缩后的结果是："+Arrays.toString(huffmanCodeBytes));//[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
        System.out.println("长度="+huffmanCodeBytes.length);

        byte[] sourceBytes = decode(huffmanCodes, huffmanCodeBytes);
        System.out.println("原来字符串="+new String(sourceBytes));

//        System.out.println(byteToBitString((byte)1));
    }


    private static void preOrder(Node root){//前序遍历的方法
        if(root!=null){
            root.preOrder();
        }else{
            System.out.println("赫夫曼树为空，无法遍历");
        }
    }


    /**
     *
     * @param bytes 接收字节数组
     * @return 返回的就是List形式[Node[date=97('a'),wight=5],Node[date=32,weight=9]]
     */
    private static List<Node> getNodes(byte[] bytes){

        //1.创建一个ArrayList
        ArrayList<Node> nodes=new ArrayList<Node>();

        //遍历bytes,统计每一个byte出现的次数 -> map[key,value]
        Map<Byte, Integer> counts = new HashMap<>();

        for (byte b:bytes) {
            Integer count = counts.get(b);
            if(count==null){//map还没有这个字符数据,第一次
                counts.put(b,1);
            }else{
                counts.put(b,count+1);
            }
        }
        //把每个键值对转成一个Node对象，并加入到nodes集合
        for(Map.Entry<Byte,Integer> entry:counts.entrySet()){//遍历map
            nodes.add(new Node(entry.getKey(),entry.getValue()));
        }
        return nodes;
    }
    
    
    //通过list创建赫夫曼树
    private static Node createHuffmanTree(List<Node> nodes){
        while(nodes.size()>1){
            //排序,从小到大
            Collections.sort(nodes);
            //取出第一颗最小的二叉树
            Node leftNode = nodes.get(0);
            //取出第二颗最小的二叉树
            Node rightNode = nodes.get(1);
            //创建一颗新的二叉树，它的根节点没有data,只有权值
            Node parent=new Node(null,leftNode.weight+rightNode.weight);
            parent.left=leftNode;
            parent.right=rightNode;
            
            //将已经处理的两颗二叉树从nodes删除
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //将新的二叉树加入到nodes
            nodes.add(parent);
        }
        //返回的节点nodes 就是赫夫曼树的根节点
        return nodes.get(0);
    }

    //生成赫夫曼树对应的赫夫曼编码
    //思路：
    //1.将赫夫曼编码表存放在Map<Byte,String> 形式如下：
    //  32 -> 01 , 97(a)->100, 100(d) ->1100 等等 （这个表可能将来不一样，形式相同）
    //2.在生成赫夫曼编码表时，需要不停的去拼接路径，定义一个StringBuilder 存储某个叶子节点的路径
    static Map<Byte,String> huffmanCodes =new HashMap<Byte,String>();
    static StringBuilder stringBuilder=new StringBuilder();

    /**
     * 功能：将传入的node节点的所有叶子节点的赫夫曼编码得到，并放入到huffmanCodes这个集合中
     * @param node 传入root根节点
     * @param code 就是路径这个值，左边为0，右边为1
     * @param stringBuilder 用于拼接路径的
     */
    private static void getcodes(Node node,String code,StringBuilder stringBuilder){
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        //将传入的code传入stringBuilder2
        stringBuilder2.append(code);
        if(node!=null){//如果node==null不处理
            //判断当前node是叶子节点还是非叶子节点
            if(node.data==null){ //非叶子节点
                //递归处理
                //向左递归
                getcodes(node.left,"0",stringBuilder2);
                //向右递归
                getcodes(node.right,"1",stringBuilder2);
            }else{ //说明是一个叶子节点
                //表示找到了某个叶子节点的最后
                huffmanCodes.put(node.data,stringBuilder2.toString());
            }
        }
    }

    //为了调用方便，重载getCodes
    private static Map<Byte,String> getcodes(Node root){
        if(root==null){
            return null;
        }
        //处理root的左子树
        getcodes(root.left,"0",stringBuilder);
        //处理root的右子树
        getcodes(root.right,"1",stringBuilder);
        return huffmanCodes;
    }



    //编写一个方法：将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]

    /**
     *
     * @param bytes 这是原始的字符串对应的byte[]
     * @param huffmanCodes 生成的赫夫曼编码map
     * @return 返回赫夫曼编码处理后的byte[]
     *
     * 举例：String content="i like like like java do you like a java"; =>
     *         byte[] contentBytes = content.getBytes();
     * 返回的是 这个字符串“1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100”
     * 也就是对应的byte[] huffmanCodeBytes,即8位对应一个byte,放入huffmanCodeBytes
     * huffmanCodeBytes[0] =
     * 10101000(补码) => byte [推导 补码->反码（补码减一）（101000111）->原码（符号位不变，其他反码）（11011000）=-88]
     * huffmanCodeBytes[1]=-88
     */
    private static byte[] zip(byte[] bytes,Map<Byte,String> huffmanCodes){
        //这个map是上面这个函数的返回值，返回了一个带有key和value的map,key是字符对应的char值，value是编号01，10，...这样的
        //然后下面这个map.get是取的map里的value的值

        //1.先利用赫夫曼编码表将传进来的byte[]转成赫夫曼编码的字符串
        StringBuilder stringBuilder = new StringBuilder();
        //遍历byte数组
        for (byte b:bytes) {
            stringBuilder.append(huffmanCodes.get(b));
        }
//        System.out.println("stringBuilder = " + stringBuilder);
        //将“1010100010111111..."转成byte[]


        //统计返回byte[] huffmanCodeBytes 长度
        //一句话int len=(stringBuilder.length()+7)/8;

        int len;
        if(stringBuilder.length()%8==0){
            len=stringBuilder.length()/8;
        } else{
            len=stringBuilder.length()/8+1;
        }
        //创建存储压缩后的byte数组
        byte[] huffmanCodeBytes=new byte[len];
        int index=0;
        for (int i = 0; i < stringBuilder.length(); i+=8) { //因为是每8位对应一个byte,所以步长+8
            String strByte;
            if(i+8>stringBuilder.length()) {//不够8位
                strByte = stringBuilder.substring(i); //这个后面不写就是从i开始取，取到最后的意思
            }else{
                strByte = stringBuilder.substring(i, i + 8);
            }
            //将strByte转成一个byte,放入到huffmanCodeBytes
            huffmanCodeBytes[index]=(byte) Integer.parseInt(strByte,2);
            index++;
        }
        return huffmanCodeBytes;
    }


    /**
     *
     * @param bytes 原始字符串对应的字节数组
     * @return  经过赫夫曼编码处理后的字节数组（压缩后的数组）
     */
    //使用一个方法，将前面的方法封装起来，便于我们的调用
    private static byte[] huffmanZip(byte[] bytes){
        List<Node> nodes = getNodes(bytes);
        //根据nodes 创建的赫夫曼树
        Node huffmanTreeRoot = createHuffmanTree(nodes);
        //根据赫夫曼树创建对应的赫夫曼map<值，值对应的赫夫曼编码>
        Map<Byte, String> huffmanCodes = getcodes(huffmanTreeRoot);
        //根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组
        byte[] huffmanCodeBytes=zip(bytes,huffmanCodes);
        return huffmanCodeBytes;
    }



    //完成数据的解压
    //思路
    //1.将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
    // 重写先转成赫夫曼对应的二进制字符串"10101000..."
    //2. 再将赫夫曼编码转成 => i like like like java do you like a java

    /**
     * 将一个byte 转成一个二进制的字符串
     * @param b
     * @param flag 表示标识是否需要补高位，如果是true表示需要补高位，如果是false表示不补(如果是最后一个字节，无需补高位)？？？？
     * @return 是该byte b对应的二进制的字符串（注意：按补码返回的数字）
     */
    private static String byteToBitString(boolean flag,byte b){
        //使用变量保存b
        int temp=b; //将b转成int
        //如果是正数我们还存在补高位
        if(flag) {
            temp |= 256; //按位或
        }
        //256=> 1 0000 0000
        //temp=>0000 0000 1
        //与后结果变为：1 0000 0001
        String str = Integer.toBinaryString(temp); //返回的是temp对应的二进制的补码
        System.out.println("Str="+str);

        if(flag){
            return str.substring(str.length()-8);
        }else{
            return str;
        }
    }

    //编写一个方法，完成对压缩数据的解码

    /**
     *
     * @param huffmanCodes 赫夫曼编码表
     * @param huffmanBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
     * @return 返回字符串对应的数组
     */
    private static byte[] decode(Map<Byte,String> huffmanCodes,byte[] huffmanBytes) {

        //1. 先得到huffmanBytes 对应的二进制的字符串，形式如："10101000..."
        StringBuilder stringBuilder = new StringBuilder();
        //将byte[]转成二进制的字符串
        for (int i = 0; i < huffmanBytes.length; i++) {
            byte b = huffmanBytes[i];
            //判断是不是最后一个字节
            boolean flag= (i==huffmanBytes.length-1);
            stringBuilder.append(byteToBitString(!flag,b));
        }
//        System.out.println("赫夫曼字节数组对应的二进制字符串"+stringBuilder.toString());

        //把字符串按照指定的赫夫曼编码进行解码
        //把赫夫曼编码表进行调换，因为反向查询 a -> 100 100->a

        Map<String,Byte> map=new HashMap<String,Byte>();
        for (Map.Entry<Byte,String> entry: huffmanCodes.entrySet()) {
            map.put(entry.getValue(),entry.getKey());
        }
//        System.out.println("map="+map);

        //创建一个集合，存放byte
        List<Byte> list=new ArrayList<>();
        for (int i = 0; i < stringBuilder.length();) { //i可以理解成就是索引，扫描stringBuilder
            int count = 1; //小的计数器
            boolean flag=true;
            Byte b=null;

            while(flag){
                //1010100010111...
                //递增的key(取出一个‘1’‘0’)
                String key=stringBuilder.substring(i,i+count); //i不动，count移动，指定匹配到一个字符
                b=map.get(key);
                if(b==null){ //说明没有匹配到
                    count++;
                }else{
                    flag=false;
                }
            }
            list.add(b);
            i+=count;//让i移动到count
        }
        //当for循环结束后，list中存放了所有的字符  i like like like java do you like a java
        byte[] b=new byte[list.size()];
        for (int i = 0; i < b.length; i++) {
            b[i] =list.get(i);
        }
        return b;
    }
}
```



##### 文件压缩

```java
    //编写方法，将文件进行压缩

    /**
     *
     * @param srcFile 传入希望压缩文件的全路径
     * @param dstFile 压缩后将压缩文件放到哪个目录
     */
    public static void zipFile(String srcFile,String dstFile){
        //创建输出流
        OutputStream os=null;
        ObjectOutputStream oos=null;
        //创建文件的输入流
        FileInputStream is=null;

        try {
             is= new FileInputStream(srcFile);
            //创建一个和源文件大小一样的byte[]
            byte[] b = new byte[is.available()];
            //读取文件
            is.read(b);
            //获取到文件对应的赫夫曼编码表
            byte[] huffmanBytes = huffmanZip(b); //之间对源文件进行压缩了
            //创建文件的输出流，存放压缩文件
            os = new FileOutputStream(dstFile);
            //创建一个和文件输出流关联的ObjectOutStream
            oos=new ObjectOutputStream(os);
            oos.writeObject(huffmanBytes); //先把huffmanBytes后的字节数组，写入压缩文件
            //这里我们以对象流的方式写入赫夫曼编码，是为了之后恢复源文件时使用
            //一定要把赫夫曼编码写入压缩文件
            oos.writeObject(huffmanCodes);

        }catch (Exception e){
            System.out.println(e.getMessage());
        }finally {
            try {
                is.close();
                oos.close();
                os.close();
            }catch (Exception e){
                System.out.println(e.getMessage());
            }
        }
    }
    //==================================================================================================================
    //编写方法，完成对压缩文件的解压

    /**
     *
     * @param zipFile 准备解压的文件
     * @param dstFile 将文件解压到哪个路径
     */
    private static void unZipFile(String zipFile,String dstFile){
        //定义文件的输入流
        InputStream is=null;
        //定义一个对象输入流
        ObjectInputStream ois=null;
        //定义文件的输出流
        OutputStream os=null;
        try{
            //创建文件输入流
            is = new FileInputStream(zipFile);
            //创建一个和is关联的对象输入流
            ois=new ObjectInputStream(is);
            //读取byte数组 huffmanBytes
            byte[] huffmanBytes  =(byte[]) ois.readObject();
            //读取赫夫曼编码表
            Map<Byte,String> huffmanCodes = (Map<Byte,String>) ois.readObject();

            //解码
            byte[] bytes = decode(huffmanCodes, huffmanBytes);
            //将bytes写入到目标文件
            os=new FileOutputStream(dstFile);
            //写出数据到 dstFile文件
            os.write(bytes);
        }catch (Exception e){
            System.out.println(e.getMessage());
        }finally {
            try{
                os.close();
                ois.close();
                is.close();
            }catch (Exception e){
                System.out.println(e.getMessage());
            }
        }
    }
===================================================================================================================// 主函数：
            //测试压缩文件
        String srcFile="C://Users//TIAN Yixin//Desktop//pic.bmp";
        String dstFile="C://Users//TIAN Yixin//Desktop//pic.zip";
        zipFile(srcFile,dstFile);
        System.out.println("压缩成功");

        //测试解压文件
        String zipFile="C://Users//TIAN Yixin//Desktop//pic.zip";
        String dstFile="C://Users//TIAN Yixin//Desktop//pic2.bmp";
        unZipFile(zipFile,dstFile);
        System.out.println("解压成功")
```

小结：（注意事项）

> 1. 如果文件本身经过压缩处理（如ppt），那么赫夫曼编码是没什么效果的
> 2. 赫夫曼编码按**字节**处理的，因此可以处理所有文件（二进制文件、文本文件）
> 3. 如果文件中，重复数据不多，压缩也没什么效果



### 二叉排序树（BST）

**二叉排序树BST**  -->  Binary Sort (Search) Tree 

​	对于二叉排序树的任何一个**非叶子节点**，要求**左子节点的值比当前节点的值小**，**右子节点的值比当前节点的值大**；如果有**相同的值**，可以将其放在**左或右子节点**。

> 例如：给定一个数列（7，3，10，12，5，1，9），如何高效的对**数据查询**和**添加**。过程就是从父节点开始比大小。
>
> 遍历结果按照：左、父、右的顺序进行打印。



通过数组创建二叉排序树，使用中序遍历二叉排序树

#### 添加和遍历

（代码在下面）

#### 删除

> 三种情况：
>
> 1. 删除叶子节点（最低端的节点）
>
>    （1）需要先去找到要删除的节点，targetNode
>
>    （2）找到targetNode的父节点 parent (考虑是否存在父节点)
>
>    （3）确定targetNode是parent的左子节点还是右子节点，然后删除
>
>    （4）根据前面的情况来对应删除
>
> 2. 删除只有一颗子树的节点（节点下面有一颗子树）
>
>    （1）需要先去找到要删除的节点，targetNode
>
>    （2）找到targetNode的父节点 parent (考虑是否存在父节点)
>
>    （3）确定target的子节点是左子节点还是右子节点
>
>    （4）targetNode是parent的左子节点还是右子节点
>
>    ​		（如此一来，四种情况）
>
> 3. 删除有两颗子树的节点
>
>    （1）需要先去找到要删除的节点，targetNode
>
>    （2）找到targetNode的父节点 parent (考虑是否存在父节点)
>
>    （3）从targetNode的右子树找到最小的节点 ？？？
>
>    （4）用一个临时变量，将最小节点的值保存temp （小？？？）
>
>    （5）删除该最大节点
>
>    （6）targetNode.value=temp



#### 代码实现

```java
package tree.binarysorttree;


// 创建node节点
public class Node2 {
    int value;
    Node2 left;
    Node2 right;
    public Node2(int value){
        this.value=value;
    }

    //查找要删除的节点
    /**
     *
     * @param value 希望删除的节点的值
     * @return 如果找到返回该节点，否则返回null
     */
    public Node2 search(int value){
        if(value==this.value){//找到，就是该节点
            return this;
        }else if(value<this.value){//如果查找的值小于当前节点，向左子树递归查找
            //如果左子节点为空
            if(this.left==null){
                return null;
            }
            return this.left.search(value);
        }else{//如果查找的值不小于当前节点，向右子树递归查找
            if(this.right==null){
                return null;
            }
            return this.right.search(value);
        }
    }
    //查找要删除节点的父节点

    /**
     *
     * @param value 要找的节点的值
     * @return 返回的是要删除的节点的父节点，如果没有返回null
     */
    public Node2 searchParent(int value){
        //如果当前节点就是要删除的节点的父节点，就返回
        if((this.left!=null&&this.left.value==value) ||
                (this.right!=null&&this.right.value==value)){
            return this;
        }else{
            //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            if(value<this.value && this.left!=null){
                return this.left.searchParent(value);//向左子树递归查找
            }else if (value>=this.value&&this.right!=null){
                return this.right.searchParent(value);//向右子树递归查找
            }else{
                return null;//没找到父节点
            }
        }
    }



    //添加节点
    //递归形式添加节点，注意需要满足二叉排序树的要求
    public void add(Node2 node){
        if(node==null){
            return;
        }
        //判断传入的节点的值，与当前子树的根节点的值比大小
        if(node.value< this.value){
            //如果当前节点左子节点为null
            if(this.left==null) {
                this.left = node;
            }else{
                //递归的向左子树添加
                this.left.add(node);
            }
            //添加的节点的值大于当前节点的值
        }else{
            if(this.right ==null){
                this.right=node;
            } else {
                //递归向右子树添加
                this.right.add(node);
            }
        }
    }

    //中序遍历
    public void infixOrder(){
        if(this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right!=null){
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node [value="+value +"]";
    }
}
//=================================================================================================================
package tree.binarysorttree;

//创建二叉排序树
public class BinarySortTree {
    private Node2 root;

    //查找要删除的节点
    public Node2 search(int value){
        if(root==null){
            return null;
        }else{
            return root.search(value);
        }
    }
    //查找父节点
    public Node2 searchParent(int value){
        if(root==null){
            return null;
        } else {
            return root.searchParent(value);
        }
    }

    //编写方法
    //1.返回以node为根节点的二叉排序树的最小节点的值
    //2.删除node 为根节点的二叉排序树的最小节点
    /**
     *
     * @param node 传入的节点（当作二叉排序树的根节点）
     * @return 返回 以node为根节点的二叉排序树的最小节点的值
     */
    public int delRightTreeMin(Node2 node){
        Node2 target=node;
        //循环的查找左节点，就会找到最小值
        while(target.left!=null){
            target=target.left;
        }
        //这时 target就指向了最小节点
        delNode(target.value);
        return target.value;
    }


    //删除节点
    public void delNode(int value){
        if(root==null){
            return;
        }else{
            //1.需要先去找到要删除的节点，targetNode
            Node2 targetNode = search(value);
            //如果没有找到要删除的节点
            if(targetNode==null){
                return;
            }
            //如果发现二叉排序树只有一个节点(证明要删的节点就是当前节点)
            if(root.left ==null&&root.right==null){
                root=null;
                return;
            }
            //去查找targetNode的父节点
            Node2 parent=searchParent(value);
            //如果要删除的节点是叶子节点
            if(targetNode.left==null&&targetNode.right==null){
                //判断targetNode是父节点的左子节点还是右子节点
                if(parent.left!=null&&value==parent.left.value){ //是左子节点
                    parent.left=null;
                }else if(parent.right!=null&&value==parent.right.value){ //是右子节点
                    parent.right=null;
                }
            } else if(targetNode.left!=null&&targetNode.right!=null){ //删除两颗子树的节点
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value=minVal;

            }else{ //删除只有一颗子树的节点
                //如果要删除的节点有左子节点
                if(targetNode.left!=null){
                    if(parent!=null) {
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                        } else { //targetNode是parent的右子节点
                            parent.right = targetNode.left;
                        }
                    }else{
                        root=targetNode.left;
                    }
                }else{ //说明要删除的节点有右子节点
                    if(parent!=null) {
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else { //如果targetNode是parent的右子节点
                            parent.right = targetNode.right;
                        }
                    }else{
                        root=targetNode.right;
                    }
                }
            }
        }
    }


    //添加节点的方法
    public void add(Node2 node){
        if(root==null){
            root=node; //如果root为空，直接让root指向node
        }else{
            root.add(node);
        }
    }
    //中序遍历
    public void infixOrder(){
        if(root!=null){
            root.infixOrder();
        }else{
            System.out.println("二叉排序树为空，不能遍历");
        }
    }
}
//=================================================================================================================
package tree.binarysorttree;

public class Test {
    public static void main(String[] args) {
        int[] arr={7,3,10,12,5,1,9,2};
        BinarySortTree binarySortTree = new BinarySortTree();
        //循环添加节点到二叉排序树
        for(int i = 0; i < arr.length; i++) {
            binarySortTree.add(new Node2(arr[i]));
        }

        //中序遍历二叉树
        System.out.println("中序遍历二叉排序树~");
        binarySortTree.infixOrder();

        //测试删除叶子节点
        binarySortTree.delNode(2);
        binarySortTree.delNode(5);
        binarySortTree.delNode(9);
        binarySortTree.delNode(12);
        binarySortTree.delNode(7);
        binarySortTree.delNode(3);
        binarySortTree.delNode(10);
        binarySortTree.delNode(1);
        System.out.println("删除节点后");
        binarySortTree.infixOrder();
    }
}
```



### 平衡二叉树（AVL）

保证查询效率较高

**它还是一颗二叉排序树！！在二叉排序树的基础上实现的！！**

> 比如数列（1，2，3，4，5，6），BST可能存在的问题：
>
> （1）全都向右子树排了，形式上看更像单链表
>
> （2）插入没问题，单查询速度明显降低
>
> （3)解决方案：平衡二叉树

**平衡二叉树特征**：

1. **空树**或者**左右子树高度差绝对值不超过1**
2. 左右零个子树，都是平衡二叉树

**平衡二叉树的实现（算法）**：红黑树、AVL、替罪羊树、Treap、伸展树



**左旋转**： （用于右子树比左子树高且相差大于1的情况）

> 1. 创建一个新的节点newNode，值等于当前根节点的值
> 2. 将新节点的左子树设置成当前节点的左子树
> 3. 将新节点的右子树设置成当前节点的右子树的左子树（这个当前节点是不停变动的）
> 4. 把当前节点的值换为右子节点的值
> 5. 把当前节点的右子树设置成当前节点的右子树的右子树
> 6. 把当前节点的左子树设置为新节点



**右旋转**：（用于左子树比右子树高且相差大于1的情况）

> 1. 创建一个新节点newNode，值等于当前根节点的值
> 2. 将新节点的右子树设置成当前节点的右子树
> 3. 将新节点的左子树设置成当前节点的左子树的右子树（与上面相同）
> 4. 把当前节点的值换为左子节点的值
> 5. 把当前节点的左子树设置成当前节点的左子树的左子树
> 6. 把当前节点的右子树设置为新节点



**双旋转**：

> 某些情况下，例如数列{10，11，7，6，8，9}，左旋转或右旋转并没有将它变成平衡树
>
> 问题分析：
>
> 1.当符合右旋转的条件时，如果左子树的右子树高度>它的右子树的高度
>
> 2.先对当前节点的左节点进行左旋转，然后再对当前节点进行右旋转的操作即可

#### 代码实现

```java
package tree.avl;

// 创建node节点
public class Node {
    int value;
    Node left;
    Node right;
    public Node(int value){
        this.value=value;
    }

    //返回左子树的高度
    public int leftHeight(){
        if(left==null){
            return 0;
        }
        return left.height();
    }

    //返回右子树的高度
    public int rightHeight(){
        if(right==null){
            return 0;
        }
        return right.height();
    }

    //返回当前节点的高度，以该节点为根节点的树的高度
    public int height(){
        return Math.max(left==null ? 0: left.height(),right==null?0:right.height())+1;
    }

    //左旋转的方法
    private void leftRotate(){
        //1.创建新的节点，=当前根节点的值
        Node newNode = new Node(value);
        //2.将新节点的左子树设置成当前节点的左子树
        newNode.left=left;
        //3.把新的节点的右子树设置成当前节点的右子树的左子树
        newNode.right=right.left;
        //4.把当前节点的值替换成右子节点的值
        value=right.value;
        //5.把当前节点的右子树设置成当前节点的右子树的右子树
        right=right.right;
        //6.把当前节点的左子树（左子节点）设置成新的节点
        left=newNode;
    }

    //右旋转方法
    private void rightRotate(){
        Node newNode = new Node(value);
        newNode.right=right;
        newNode.left=left.right;
        value=left.value;
        left=left.left;
        right=newNode;
    }


    //查找要删除的节点
    /**
     *
     * @param value 希望删除的节点的值
     * @return 如果找到返回该节点，否则返回null
     */
    public Node search(int value){
        if(value==this.value){//找到，就是该节点
            return this;
        }else if(value<this.value){//如果查找的值小于当前节点，向左子树递归查找
            //如果左子节点为空
            if(this.left==null){
                return null;
            }
            return this.left.search(value);
        }else{//如果查找的值不小于当前节点，向右子树递归查找
            if(this.right==null){
                return null;
            }
            return this.right.search(value);
        }
    }
    //查找要删除节点的父节点

    /**
     *
     * @param value 要找的节点的值
     * @return 返回的是要删除的节点的父节点，如果没有返回null
     */
    public Node searchParent(int value){
        //如果当前节点就是要删除的节点的父节点，就返回
        if((this.left!=null&&this.left.value==value) ||
                (this.right!=null&&this.right.value==value)){
            return this;
        }else{
            //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            if(value<this.value && this.left!=null){
                return this.left.searchParent(value);//向左子树递归查找
            }else if (value>=this.value&&this.right!=null){
                return this.right.searchParent(value);//向右子树递归查找
            }else{
                return null;//没找到父节点
            }
        }
    }



    //添加节点
    //递归形式添加节点，注意需要满足二叉排序树的要求
    public void add(Node node){
        if(node==null){
            return;
        }
        //判断传入的节点的值，与当前子树的根节点的值比大小
        if(node.value< this.value){
            //如果当前节点左子节点为null
            if(this.left==null) {
                this.left = node;
            }else{
                //递归的向左子树添加
                this.left.add(node);
            }
            //添加的节点的值大于当前节点的值
        }else{
            if(this.right ==null){
                this.right=node;
            } else {
                //递归向右子树添加
                this.right.add(node);
            }
        }

        //当添加完一个节点后，如果:(右子树的高度-左子树的高度>1),则进行左旋转
        if(rightHeight()-leftHeight()>1){
            //如果它的右子树的左子树的高度大于它的右子树的高度
            //先对它的右子节点进行右旋转，再对当前节点进行左旋转
            if(right!=null&&right.leftHeight()>right.rightHeight()){
                right.rightRotate();
                leftRotate();//左旋转
            }else{
                leftRotate();
            }
            return;
        }

        //当添加完一个节点后，如果:(左子树的高度-右子树的高度>1),则进行右旋转
        if(leftHeight()-rightHeight()>1){
            //如果它的左子树的右子树高度大于它的左子树的高度
            if(left!=null&&left.rightHeight()>left.leftHeight()) {
                //先对当前节点的左节点（左子树）->进行左旋转
                left.leftRotate();
                //再对当前节点进行右旋转
                rightRotate();//左旋转
            }else{
                //直接进行右旋转即可
                rightRotate();
            }
            return;
        }
    }

    //中序遍历
    public void infixOrder(){
        if(this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right!=null){
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node [value="+value +"]";
    }
}
//=================================================================================================================
package tree.avl;

//创建AVLtree
public class AVLTree {
    private Node root;
    public Node getRoot(){
        return root;
    }

    //查找要删除的节点
    public Node search(int value){
        if(root==null){
            return null;
        }else{
            return root.search(value);
        }
    }
    //查找父节点
    public Node searchParent(int value){
        if(root==null){
            return null;
        } else {
            return root.searchParent(value);
        }
    }

    //编写方法
    //1.返回以node为根节点的二叉排序树的最小节点的值
    //2.删除node 为根节点的二叉排序树的最小节点
    /**
     *
     * @param node 传入的节点（当作二叉排序树的根节点）
     * @return 返回 以node为根节点的二叉排序树的最小节点的值
     */
    public int delRightTreeMin(Node node){
        Node target=node;
        //循环的查找左节点，就会找到最小值
        while(target.left!=null){
            target=target.left;
        }
        //这时 target就指向了最小节点
        delNode(target.value);
        return target.value;
    }


    //删除节点
    public void delNode(int value){
        if(root==null){
            return;
        }else{
            //1.需要先去找到要删除的节点，targetNode
            Node targetNode = search(value);
            //如果没有找到要删除的节点
            if(targetNode==null){
                return;
            }
            //如果发现二叉排序树只有一个节点(证明要删的节点就是当前节点)
            if(root.left ==null&&root.right==null){
                root=null;
                return;
            }
            //去查找targetNode的父节点
            Node parent=searchParent(value);
            //如果要删除的节点是叶子节点
            if(targetNode.left==null&&targetNode.right==null){
                //判断targetNode是父节点的左子节点还是右子节点
                if(parent.left!=null&&value==parent.left.value){ //是左子节点
                    parent.left=null;
                }else if(parent.right!=null&&value==parent.right.value){ //是右子节点
                    parent.right=null;
                }
            } else if(targetNode.left!=null&&targetNode.right!=null){ //删除两颗子树的节点
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value=minVal;

            }else{ //删除只有一颗子树的节点
                //如果要删除的节点有左子节点
                if(targetNode.left!=null){
                    if(parent!=null) {
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                        } else { //targetNode是parent的右子节点
                            parent.right = targetNode.left;
                        }
                    }else{
                        root=targetNode.left;
                    }
                }else{ //说明要删除的节点有右子节点
                    if(parent!=null) {
                        //如果targetNode是parent的左子节点
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else { //如果targetNode是parent的右子节点
                            parent.right = targetNode.right;
                        }
                    }else{
                        root=targetNode.right;
                    }
                }
            }
        }
    }


    //添加节点的方法
    public void add(Node node){
        if(root==null){
            root=node; //如果root为空，直接让root指向node
        }else{
            root.add(node);
        }
    }
    //中序遍历
    public void infixOrder(){
        if(root!=null){
            root.infixOrder();
        }else{
            System.out.println("二叉排序树为空，不能遍历");
        }
    }
}
//=================================================================================================================
package tree.avl;

public class Test {
    public static void main(String[] args) {
//        int[] arr={4,3,6,5,7,8};
//        int[] arr={10,12,8,9,7,6};
        int[] arr={10,11,7,6,8,9};
        //创建一个AVLtree对象
        AVLTree avlTree = new AVLTree();
        //添加节点
        for (int i = 0; i < arr.length; i++) {
            avlTree.add(new Node(arr[i]));
        }

        //遍历
        System.out.println("中序遍历");
        avlTree.infixOrder();
//        System.out.println("左旋转之后：");
        System.out.println("右旋转之前：");
        System.out.println("树的高度："+avlTree.getRoot().height());
        System.out.println("左子树的高度："+avlTree.getRoot().leftHeight());
        System.out.println("右子树树的高度："+avlTree.getRoot().rightHeight());
        System.out.println("当前根节点="+avlTree.getRoot());
    }
}
```



### 多路查找树

#### 二叉树

> 二叉树问题分析：（二叉树操作效率较高，但存在一些问题）
>
> 二叉树需要加载到内存进行操作和访问，如果二叉树的节点很多，可能会存在以下问题：（一般节点少没什么问题）
>
> （1）在内存中构建二叉树时，需要多次进行 I/O 操作（一般数据会存在数据库或文件中，需要从其中进行读取），速度有影响
>
> （2）节点海量，会造成二叉树的高度很大，会降低操作速度

#### 多叉树

> 跟二叉树概念相对，多叉树（multiway tree）允许每个节点有更多的数据项和更多的子节点。
>
> 多叉树能减少树的高度，对二叉树进行优化。

#### B树、B+树和B*树

B即是balanced的意思。B树是多叉树的一种。

> B树通过重新组织节点，降低树的高度，并减少 I/O 读写次数来提升效率。
>
> B树的特征：一个树的度M一般设置为1024，所有叶子节点都在同一层。（**节点的度Degree指的是一个节点拥有的子节点的数量**）
>
> 一般，B（B+）树广泛应用于文件存储系统或者数据库系统中，其设计者利用磁盘预读原理，将一个节点大小（也就是多少个数据）设置为一个页（1page=4k），这样每个节点只需要一次 I/O 就可以完全载入。



**在学习数据库时，经常听到某种类型的索引基于B树或B+树**：

**B树**：

> --> **B树的阶**：一颗B树所有节点中，子树最多的个数（如：2-3-4树，阶=4）
>
> （1）搜索从根节点开始，对节点内关键字（要查找的值），有序序列进行二分查找，如果找到就结束，直到指针为空或已经到叶子节点
>
> （2）关键字集合分布在整颗树中，也就是说，叶子节点和非叶子节点都可以存放数据
>
> （3）结束可能在非叶子节点处，跟B+树对比
>
> （4）搜索性能等价于在全集内做一次二分查找



**B+树**：

> （1）B+树搜索与B树基本相同，区别是**B+树只有达到叶子节点才结束**
>
> （2）所有**关键字都出现在叶子节点的链表中**（也就是数据只能在叶子节点 --> **稠密索引** ），链表中的关键字也是有序的
>
> （3）非叶子节点都是叶子节点的索引 --> **稀疏索引**，所以查找不可能在非叶子节点找到
>
> （4）B+树更适合文件索引系统
>
> 
>
> 注： 可能是这样的，树的最底层部分每一条都是一个有序链表，所有这些链表开头的值（每一条）当作索引，所以其实B+是通过分段再分段进行索引的，（应该要比二分查找快的多？？？）



**B*树**：

> B*树是B+树的变体，**在B+树的非根和非叶子节点再增加指向指针**
>
> （1）B*树定义非叶子节点关键字个数至少为 2/3 * M （M为树的度）
>
> （2）也就是说，块的最低使用率为2/3，而B+树的块的最低使用率为B*树的1/2（？？？）
>
> （3）B*树分配新节点的概率比B+树要低，空间使用率更高



#### 2-3树

2-3树是最简单的B树

> 特征：
>
> （1）一个节点最多有两个数据元素（数据项为2），所有叶子节点都在同一层
>
> （2）有两个子节点的节点叫**二节点**，二节点**没有子节点或两个子节点**
>
> （3）有三个子节点的节点叫**三节点**，三节点**没有子节点或三个子节点**
>
> ​	（注：节点两个数据项，它的左子树，比最小的小，中间那个处于两数之间，右子树，比最大的大）
>
> （4）**2-3树是由二节点和三节点构成的树**
>
> 
>
> **注**：在构建的过程中，如果一个节点有一个数据项，那么它要么没有子树，要么就必须两颗子树；如果一个节点有两个数据项，那么它要么没有子树，要么就必须三颗子树。一个节点至多两个数据项。高度必须相同。以上要求，必须全程遵守！！！！

#### 2-3-4树

2-3-4树也是B树的一种





## 图

有时候，我们需要处理多对多的关系。

图是一种数据结构，其中节点可以具有0个或多个相邻元素。**两个节点之间的连接称为边**。**节点称为顶点**。

> 常用概念：
>
> （1）顶点（vertex）：节点
>
> （2）边（edge）
>
> （3）路径
>
> （4）无向图（有图）：没有方向，A->B，B也可以->A
>
> （5）有向图
>
> （6）带权图：边带权重的图，也叫做**网**



**图的表示方式**：

两种：**邻接矩阵**或者**邻接表**

> 邻接矩阵：表示图形中顶点之间相邻关系的矩阵。图中顶点的值是行和列的值，有向或无向的区别用0或1表示
>
> 邻接表：将图中所有出现的顶点的值，跟其相关联的节点组成链表。由数组+链表组成。

邻接矩阵会造成一定的空间浪费，邻接表会好很多。



### 图的创建代码实现

0表示不能直连，1表示能够直连

> 思路：
>
> （1）存储顶点String，使用ArrayList
>
> （2）保存矩阵 int [ ] [ ] edges

```java
import java.util.ArrayList;
import java.util.Arrays;

//建立图结构思路：
//属性：值（顶点）：ArrayList<String>,边（从哪连到哪）：整数二维数组, 边的数目
class Test{
    //图的属性
    private ArrayList<String> vertexList;//顶点
    private int[][] edges; //边 -> 对应邻接矩阵，用0,1表示
    private int numberOfEdges; //顶点边的数量

    //构造器
    public Test(int n){ //n表示0或1，连接或没连接
        edges=new int[n][n];    //这里是new了一数组，后面那个n是指定多少行多少列
        vertexList=new ArrayList<String>(n);
        numberOfEdges=0;
    }
    //插入节点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    //添加边
    public void insertEdge(int v1,int v2,int weight){ //这里的v1,v2表示顶点的下标
        // weight才是0或1，有向还是无向，因为是无向图，所以所有weight=1
      edges[v1][v2]=weight; //这里才是填空数组值的
      edges[v2][v1]=weight;
      numberOfEdges++;
    }

    //图的一些常用方法：
    //返回节点的个数
    public int getNumberOfVertex(){
        return vertexList.size();
    }

    //得到边的数目
    public int getNumberOfEdges(){
        return numberOfEdges;
    }

    //返回节点i(下标)对应的数据 0->"A" 1-> "B"
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    //返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    //显示图对应矩阵
    public void showGraph(){
        for (int[] link:edges) {
            System.out.println(Arrays.toString(link));
        }
    }

    public static void main(String[] args) {
        //测试图创建代码
        int n = 5;//节点的数目
        String Vertexs[] = {"A","B","C","D","E"};
        //创建图对象
        Test graph = new Test(n);
        //循环添加顶点
        for(String vertex:Vertexs){
            graph.insertVertex(vertex);
        }
        //添加边
        //A-B A-C B-C B-D B-E
        graph.insertEdge(0,1,1); //A-B
        graph.insertEdge(0,2,1); //A-C
        graph.insertEdge(1,2,1); //B-C
        graph.insertEdge(1,3,1); //B-D
        graph.insertEdge(1,4,1); //B-E
        graph.showGraph();
    }
}
//结果返回:
//[0, 1, 1, 0, 0]
//[1, 0, 1, 1, 1]
//[1, 1, 0, 0, 0]
//[0, 1, 0, 0, 0]
//[0, 1, 0, 0, 0]


//这个方法，先要独立添加顶点，也就是String值，再将顶点通过edges数组联系起来，顶点通过下标表示，添加的值代表有向还是无向（0或1），每添加一次，边的个数+1。最后通过方法调用这些属性。
```



### 图的深度优先遍历（DFS）

Depth First Search

> 思路：
>
> （1）从初始节点开始访问，然后访问它的第一个邻接节点，再以当前被访问的节点为初始节点，访问它的第一个邻接节点。
>
> （2）这个策略是优先往**纵向深入挖掘**，而不是对某一结点所有邻接节点进行横向访问
>
> （3）这是一个递归的过程

算法步骤：

> （1）访问初始节点v，并标记v为已访问（！！重要）
>
> （2）查找节点v下一个邻接节点w  （w代表下标）
>
> （3）若节点w存在，则（4），否则回到（1）从以一个节点继续
>
> （4）若w未访问，对w进行dfs（递归实现）
>
> （5）查找节点v的w邻接节点的下一个邻接节点，转到（3）

```java
package graph.basic_graph;

import java.util.ArrayList;
import java.util.Arrays;

public class Graph {

    private ArrayList<String> vertexList; //存储顶点的集合
    private int[][] edges; //存储图对应的邻接矩阵
    private int numOfEdges; //表示边的数目
    //定义一个数组boolean[],记录某个节点是否被访问过
    private boolean[] isVisited;


    //构造器
    public Graph(int n){
        //初始化矩阵和vertexList
        edges=new int[n][n];
        vertexList=new ArrayList<String>(n);
        numOfEdges=0;
        isVisited=new boolean[5];
    }

    //得到当前节点的第一个邻接节点的下标
    /**
     *
     * @param index
     * @return 如果存在，就返回对应下标，否则，返回-1
     */
    public int getFirstNeighbor(int index){ //当前节点下标
        for (int j = 0; j < vertexList.size(); j++) {
            if(edges[index][j]>0){ //按顺序走，自己和自己的weight也为0
                //但是这里没判断标记是否是true
                return j;   //一旦得到weight=1,说明找到邻接节点了，马上返回
            }
        }
        return -1;
    }

    //根据前一个邻接节点的下标，来获取下一个邻接节点的下标
    public int getNextNeighbor(int v1,int v2){
        for (int j = v2+1; j < vertexList.size(); j++){
            //这个方法倒是判断了，排除自身以及前面顶点，也就不存是否有标记过的事了
            if(edges[v1][j]>0){ //说明存在
                return j;
            }
        }
        return -1;
    }
    //深度优先遍历算法dfs
    //i 第一次就是0 （表示初始顶点的下标）
    public void dfs(boolean[] isVisited,int i){
        //首先，访问该节点
        System.out.print(getValueByIndex(i)+"->");
        //将访问过的节点置于已访问
        isVisited[i]=true;

        //查找节点v下一个邻接节点w  （w代表下标）
        int w=getFirstNeighbor(i);
        while(w!=-1){//说明有邻接节点
            if(!isVisited[w]){
                dfs(isVisited,w);
            }
            //如果w已经被访问过，那么：
            //查找节点v的w邻接节点的下一个邻接节点
            w=getNextNeighbor(i,w);
        }
    }

    //对dfs 进行一个重载,遍历所有的节点，并进行dfs
    //重载概念回忆：它允许一个类具有多个具有不同参数列表的构造函数。
    public void dfs(){
        //遍历所有的节点，进行dfs[回溯]
        for (int i = 0; i < getNumberOfVertex(); i++) {
            if(!isVisited[i]){
                dfs(isVisited,i);
            }
        }
    }


    //图中常用的方法
    //返回节点的个数
    public int getNumberOfVertex(){
        return vertexList.size();
    }
    //得到边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    //返回节点i(下标)对应的数据 0->"A" 1->"B" 2->"C"
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    //返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    //显示图对应的矩阵
    public void showGraph(){
        for (int[] link:edges){
            System.out.println(Arrays.toString(link));
        }
    }

    //插入节点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    //添加边

    /**
     *
     * @param v1 表示点的下标，即第几个顶点
     * @param v2 表示第2个顶点对应的下标
     * @param weight
     */
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2]=weight;
        edges[v2][v1]=weight;
        numOfEdges++;
    }

    public static void main(String[] args) {
        //测试图创建代码
        int n = 5;//节点的数目
        String Vertexs[] = {"A","B","C","D","E"};
        //创建图对象
        Graph graph = new Graph(n);
        //循环添加顶点
        for(String vertex:Vertexs){
            graph.insertVertex(vertex);
        }
        //添加边
        //A-B A-C B-C B-D B-E
        graph.insertEdge(0,1,1); //A-B
        graph.insertEdge(0,2,1); //A-C
        graph.insertEdge(1,2,1); //B-C
        graph.insertEdge(1,3,1); //B-D
        graph.insertEdge(1,4,1); //B-E
        graph.showGraph();

        //测试深度遍历dfs
        System.out.println("深度遍历：");
        graph.dfs();
    }
}
```





### 图的广度优先遍历（BFS）

Broad First Search

> 基本思想：需要**使用一个队列以保持访问过的节点的顺序**，以便按这个顺序来访问这些节点的邻接节点。

算法步骤：

> （1）访问初始节点v，标记 v -> 已访问。节点 v 入队列
>
> （2）队列为空时，继续执行，队列不为空，算法结束
>
> （3）如果当前节点找不到了（当前节点已经出队列），那么队列弹出最前面一个，得到队头节点 u
>
> （4）查找节点 u 的第一个邻接节点 w，若 w 存在：
>
> ​		a. 若节点w尚未被访问，则访问节点w并标记已访问
>
> ​		b. 节点w入队列
>
> ​		c. 查找u继w邻接节点后的下一个邻接节点w，回到（4）
>
> （5）若节点 u 的邻接节点 w 不存在，则转到（3）

```java
package graph.basic_graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

public class Graph {

    private ArrayList<String> vertexList; //存储顶点的集合
    private int[][] edges; //存储图对应的邻接矩阵
    private int numOfEdges; //表示边的数目
    //定义一个数组boolean[],记录某个节点是否被访问过
    private boolean[] isVisited;


    //构造器
    public Graph(int n){
        //初始化矩阵和vertexList
        edges=new int[n][n];
        vertexList=new ArrayList<String>(n);
        numOfEdges=0;
        isVisited=new boolean[5];
    }

    //得到当前节点的第一个邻接节点的下标
    /**
     *
     * @param index
     * @return 如果存在，就返回对应下标，否则，返回-1
     */
    public int getFirstNeighbor(int index){ //当前节点下标
        for (int j = 0; j < vertexList.size(); j++) {
            if(edges[index][j]>0){ //按顺序走，自己和自己的weight也为0
                //但是这里没判断标记是否是true
                return j;   //一旦得到weight=1,说明找到邻接节点了，马上返回
            }
        }
        return -1;
    }

    //根据前一个邻接节点的下标，来获取下一个邻接节点的下标
    public int getNextNeighbor(int v1,int v2){
        for (int j = v2+1; j < vertexList.size(); j++){
            //这个方法倒是判断了，排除自身以及前面顶点，也就不存是否有标记过的事了
            if(edges[v1][j]>0){ //说明存在
                return j;
            }
        }
        return -1;
    }
    //深度优先遍历算法dfs
    //i 第一次就是0 （表示初始顶点的下标）
    private void dfs(boolean[] isVisited,int i){
        //首先，访问该节点
        System.out.print(getValueByIndex(i)+"->");
        //将访问过的节点置于已访问
        isVisited[i]=true;

        //查找节点v下一个邻接节点w  （w代表下标）
        int w=getFirstNeighbor(i);
        while(w!=-1){//说明有邻接节点
            if(!isVisited[w]){
                dfs(isVisited,w);
            }
            //如果w已经被访问过，那么：
            //查找节点v的w邻接节点的下一个邻接节点
            w=getNextNeighbor(i,w);
        }
    }

    //对dfs 进行一个重载,遍历所有的节点，并进行dfs
    //重载概念回忆：它允许一个类具有多个具有不同参数列表的构造函数。
    public void dfs(){
        isVisited=new boolean[5];
        //遍历所有的节点，进行dfs[回溯]
        for (int i = 0; i < getNumberOfVertex(); i++) {
            if(!isVisited[i]){
                dfs(isVisited,i);
            }
        }
    }


    //对一个节点进行广度优先遍历的方法
    private void bfs(boolean[] isVisited,int i){
        int u; //代表队列的头节点对应的下标
        int w; //u的第一个邻接节点的下标
        //队列,记录节点访问的顺序
        LinkedList queue = new LinkedList();
        //访问节点，输出节点信息
        System.out.print(getValueByIndex(i)+"->");
        //标记为已访问
        isVisited[i]=true;
        //将节点加入队列.(队列加入尾部，取出头部)
        queue.addLast(i);

        while(!queue.isEmpty()){
            //取出队列的头部节点下标
            u=(Integer) queue.removeFirst();
            //得到第一个邻接点的下标w
            w=getFirstNeighbor(u);
            while(w !=-1){ //找到
                //是否访问过
                if(!isVisited[w]){
                    System.out.print(getValueByIndex(w)+"->");
                    //标记已访问
                    isVisited[w]=true;
                    //入队
                    queue.addLast(w);
                }
                //以u为起始点，去找w的下一个邻接节点
                w = getNextNeighbor(u, w); //体现出广度优先
            }
        }

    }

    //遍历所有的节点，都进行广度优先搜索
    public void bfs(){
        isVisited=new boolean[5];
        for (int i = 0; i < vertexList.size(); i++) {
            if(!isVisited[i]) {
                bfs(isVisited, i);
            }
        }
    }



    //图中常用的方法
    //返回节点的个数
    public int getNumberOfVertex(){
        return vertexList.size();
    }
    //得到边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    //返回节点i(下标)对应的数据 0->"A" 1->"B" 2->"C"
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    //返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    //显示图对应的矩阵
    public void showGraph(){
        for (int[] link:edges){
            System.out.println(Arrays.toString(link));
        }
    }

    //插入节点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    //添加边

    /**
     *
     * @param v1 表示点的下标，即第几个顶点
     * @param v2 表示第2个顶点对应的下标
     * @param weight
     */
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2]=weight;
        edges[v2][v1]=weight;
        numOfEdges++;
    }

    public static void main(String[] args) {
        //测试图创建代码
        int n = 5;//节点的数目
        String Vertexs[] = {"A","B","C","D","E"};
        //创建图对象
        Graph graph = new Graph(n);
        //循环添加顶点
        for(String vertex:Vertexs){
            graph.insertVertex(vertex);
        }
        //添加边
        //A-B A-C B-C B-D B-E
        graph.insertEdge(0,1,1); //A-B
        graph.insertEdge(0,2,1); //A-C
        graph.insertEdge(1,2,1); //B-C
        graph.insertEdge(1,3,1); //B-D
        graph.insertEdge(1,4,1); //B-E
        graph.showGraph();

        //测试深度遍历dfs
        System.out.println("深度优先：");
        graph.dfs();
        System.out.println();
        //测试广度遍历bfs
        System.out.println("广度优先：");
        graph.bfs();
    }
}
```



### 对比 DFS 和 BFS

```java
// 更换顶点如下：
// String Vertexs[] = {"1","2","3","4","5","6","7","8"};
//运行结果变为：

//深度优先：
//1->2->4->8->5->3->6->7->
//广度优先：
//1->2->3->4->5->6->7->8->
```

###  

# 算法

**数据结构的实际应用**



## 程序员常用的10种算法



### 1. 二分查找算法（非递归）

只适用于从**有序数列**种进行查找，将数列排序后再进行查找。

**时间复杂度**：**O(log~2~ n)**

```java
package algorithm.binarysearchnorecursion;

public class BinarySearchNoRecur {
    public static void main(String[] args) {
        //测试
        int[] arr={1,3,8,10,11,67,100};
        int index = binarySearch(arr, -8);
        System.out.println("index="+index);
    }

    //二分查找的非递归实现

    /**
     *
     * @param arr 待查找的数组,arr是升序排列
     * @param target 需要查找的数
     * @return 返回下标，-1表示没有
     */
    public static int binarySearch(int[] arr,int target){
        int left=0;
        int right= arr.length-1;
        while(left<=right){//说明继续查找
            int mid=(left+right)/2;
            if(arr[mid]==target){
                return mid;
            }else if(arr[mid]>target){
                right=mid-1; //需要向左边查找
            }else{
                left=mid+1; //需要向右边查找
            }
        }
        return -1;
    }
}

```





### 2. 分治算法

二分查找算法算是分治算法的一种，是分治算法的重要体现。

> **分治法的思想**：把一个复杂的问题分成两个或更多**相同或相似的子问题**，直到最后子问题可以简单直接求解，原问题的解即子问题的解的合并。
>
> 它是很多高效算法的基础，如排序算法（快速排序，归并排序），傅里叶变换（快速傅里叶变换）...

基本步骤：

> 1. **分解**：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
> 2. **解决**：将子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
> 3. **合并**：将各个子问题的解合并为原问题的解



汉诺塔规则：

> 有三根杆子A，B，C。A杆上有 64 个穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：
>
> 1. 每次只能移动一个圆盘；
> 2. 大盘不能叠在小盘上面。
>
> 如何移？最少要移动多少次？

思路分析：

> A. 如果一个盘，A -> C
>
> B.如果有n>=2盘，可以总是看做是两个盘：1.最下边的一个盘；2.上面的所有盘:
>
> ​	a. 先把最上面的盘 A -> B
>
> ​	b. 把最下边的盘 A -> C
>
> ​	c. 把B盘所有的盘从 B -> C

```java
package algorithm.dac;

public class Hanoitower {
    public static void main(String[] args) {
//        hanoiTower(1,'A','B','C');
//        hanoiTower(2,'A','B','C');
        hanoiTower(5,'A','B','C');
    }

    //汉诺塔的移动的方法
    //使用分治算法
    public static void hanoiTower(int num,char a,char b,char c){
        //如果只有一个盘
        if(num==1){
            System.out.println("第1个盘从"+a+"->"+c);
        } else{
            //如果有n>=2盘，可以总是看做是两个盘：1.最下边的一个盘；2.上面的所有盘
            //1.先把最上面的所有盘A->B,移动过程会使用C
            hanoiTower(num-1,a,c,b);
            //2.把最下边的盘 A -> C
            System.out.println("第"+num+"个盘从"+a+"->"+c);
            //3.把B盘所有的盘从 B -> C,移动过程使用到A塔
            hanoiTower(num-1,b,a,c);
        }
    }
}
```



### 3. 动态规划

> **应用场景-背包问题**：
>
> 背包重量4磅
>
> | 物品 | 重量 | 价格 |
> | :--: | :--: | :--: |
> | 吉他 |  1   | 1500 |
> | 音响 |  4   | 3000 |
> | 电脑 |  3   | 2000 |
>
> （1）达到的目标为装入的背包的总价值最大，并且重量不超出
>
> （2）装入的物品不能重复
>
> --> 用**动态规划**进行求解

**动态规划算法**：

> （1）核心思想是：大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
>
> （2）与分治算法类似，但不同处在于，**适合于动态规划求解的问题，经分解得到的小问题往往不是相互独立的**
>
> （3)可以通过填表的方式逐步推进，得到最优解



**背包问题思路分析**:

> （1）背包问题主要指一个给定容量的背包，若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大
>
> （2）分为**01背包**（每个物品最多放一个）和**完全背包**（每个物品可以无限使用）
>
> （3）无线背包可以转化为01背包
>
> 
>
> 思路：
>
> （1）对于给定的n个物品，每次遍历到的第i个物品，v[i] （--> 物品价值）和w[i]（-->物品重量）来确定是否需要将物品放入背包
>
> （2）C为背包的容量，v[i] [j] （i表示前i个物品，j表示能够装入的容量）->表示能够装入背包的最大价值

```java
package algorithm.dynamic;

public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w={1,4,3};//物品的重量
        int[] val={1500,3000,2000};//物品的重量,这里的val[i]就是笔记里的v[i]
        int m=4; //背包的容量
        int n= val.length; //物品的个数



        //创建二维数组
        //v[i][j] 表示在前i个物品中能够装入物品最大的价值
        //这个二维数组的行表示物品(下标)，列表示从0到m(背包容量)的容量
        int[][] v=new int[n+1][m+1];
        //为了记录放入商品的情况，我们定一个二维数组
        int[][] path=new int[n+1][m+1];

        //初始化第一行和第一列，这里在本程序中，可以不去处理，因为默认就是0
        for (int i = 0; i < v.length; i++) {
            v[i][0]=0; //将第一列置为0
        }
        for (int i = 0; i < v[0].length; i++) {
            v[0][i]=0;//将第一行置为0
        }

        //根据前面得到的公式来动态规划处理
        //v是那个二维数组，w是重量
        for (int i = 1; i < v.length; i++) { //不处理第一行 i从1开始的
            for (int j = 1; j < v[0].length; j++) { //不处理第一列 j是从1开始的
                //公式
                //这个是判读当前重量太重，放不进目标为止的重量背包里
                if(w[i-1]>j){ //因为我们的程序i 是从1开始 因此要w[i-1],下边的下标都要如此处理
                    v[i][j]=v[i-1][j]; //因为放不进，所以放上一行的物品价值，也就是copy一下
                }else{ //否则就是能放进去
//                    v[i][j]=Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);
                    //为了记录商品存放到背包的情况，我们不能简单的使用Math.max,需要使用if-else来记录
                    if(v[i-1][j]<val[i-1]+v[i-1][j-w[i-1]]){
                        v[i][j]=val[i-1]+v[i-1][j-w[i-1]];
                        path[i][j]=1;
                    }else{
                        v[i][j]=v[i-1][j];
                    }
                }
            }
        }

        //输出一下v
        for (int i = 0; i < v.length; i++) {
            for (int j = 0; j < v[i].length; j++) {
                System.out.print(v[i][j]+" ");
            }
            System.out.println();
        }
        System.out.println("=======================");
        //输出最后我们是放入的哪些商品
        //遍历path,这样输出会把所有情况都得到，其实我们只需要最后的放入
//        for (int i = 0; i < path.length; i++) {
//            for (int j = 0; j < path[i].length; j++) {
//                if(path[i][j]==1) {
//                    System.out.printf("第%d个商品放入到背包\n", i);
//                }
//            }
//        }

        int i=path.length-1; //行的最大下标
        int j=path[0].length-1; //列的最大下标
        while(i>0 && j>0){ //从path的最后开始找
            if(path[i][j]==1){
                System.out.printf("第%d个商品放入到背包\n", i);
                j-=w[i-1]; //v的重量-重量
            }
            i--;
        }
    }
}
```



### 4. KMP算法

> 字符串匹配问题：
>
> str1="硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好"，str2="尚硅谷你尚硅你"
>
> 判断str1是否含有str2，如果存在，返回第一次出现的位置，如果没有，返回-1
>
> （1）暴力匹配思路：
>
> a. 索引i指向str1，索引j指向str2，如果当前字符匹配成功，则i++，j++，继续匹配下一个
>
> b. 如果失配，令i=i-(j-1) ,j=0。相当于每次匹配失败，i回溯，j被置为0
>
> c.用暴力方法的话，大量回溯，每次只移动一位，若是不匹配，移动到下一位接着判断（不可行！）

```java
package algorithm.kmp;

public class ViolenceMatch {
    public static void main(String[] args) {
        //测试
        String str1="硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
        String str2="尚硅谷你尚硅你";
        int index = violenMatch(str1, str2); //应该是15
        System.out.println("index="+index); //index=15
    }

    //暴力匹配
    public static int violenMatch(String str1,String str2){
        char[] s1=str1.toCharArray();
        char[] s2=str2.toCharArray();

        int s1Len=s1.length;
        int s2Len=s2.length;
        int i=0; //i是str1的索引
        int j=0; //j是str2的索引
        while(i<s1Len && j<s2Len){ //保证不越界

            if(s1[i]==s2[j]){//匹配成功
                i++;
                j++;
            }else{//没有匹配成功
                //如果失配，令i=i-(j-1) ,j=0。相当于每次匹配失败，i回溯，j被置为0
                i=i-(j-1);
                j=0;
            }
        }
        //判断是否匹配成功
        if(j==s2Len){
            return i-j;
        }else{
            return -1;
        }
    }
}
```



> （2）KMP算法：
>
> a. 解决”模式串在文本串里是否出现过，如果出现过，返回最早出现的位置“的经典算法
>
> b. KMP三个字母分别代表三个作者
>
> c.利用之前判断过的信息，通过一个next数组(部分数组词)，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到前面匹配过的位置，省去了大量的计算时间
>
> 
>
> 例：str1="BBC ABCDAB ABCDABCDABDE" 和 str2="ABCDABD"
>
> 
>
> （!!!我懂辽！！！我真的太聪明辽！！哈哈哈哈哈！给我牛逼坏了，叉会腰~）
>
> 这个搜索词next是这样的：
>
> 以”ABCDABD“为例，**移动位数=已经匹配的字符长度-对应的部分匹配值**
>
> 它有一个对应的部分匹配值，比如当字符没有重复时，就是0。相当于移动位数=要匹配的字符长度-0，也就是整体往后移。
>
> 有重复时，那么对应的值就变为1。移位数=长度-1。（AAAB和AAB，向后移3-1=2位）
>
> 当有重复且不同字符时，依次往后变为2。移位数=长度-2。（ABCABAB和ABCAB，向后移5-2=3）
>
> 当重复突然断了时，匹配值重新变为0。（ABCDABD->0000120）
>
> 比如：AAAAD和AAAD，AAAD的值就是->(0120) 
>
> 
>
> 部分匹配值：是前缀和后缀共有元素的最长长度。

思路：

> 1.先得到子串的部分匹配表；2.使用部分匹配表完成KMP匹配

```java
package algorithm.kmp;

import java.util.Arrays;

public class KMPAlgorithm {
    public static void main(String[] args) {
        String str1="BBC ABCDAB ABCDABCDABDE";
        String str2="ABCDABD";
//        String str2="BBC";

//        int[] next = kmpNext("AAA"); //[0,1,2]
//        int[] next = kmpNext("AAAB"); //[0,1,2,0]
        int[] next = kmpNext("ABCDABD"); //[0, 0, 0, 0, 1, 2, 0]
//        int[] next = kmpNext("BBC");
        System.out.println("next="+Arrays.toString(next));
        System.out.println("--------");
        int index = kmpSearch(str1, str2, next);
        System.out.println("index="+index);

    }

    //写出我们的kmp搜索算法
    /**
     *
     * @param str1 原字符串
     * @param str2 子串
     * @param next 部分匹配表，是子串对应的值
     * @return 如果是-1，就是没有匹配到，否则返回第一个匹配的位置
     */
    public static int kmpSearch(String str1,String str2,int[] next){
        //遍历
        for (int i = 0,j=0; i < str1.length(); i++) {//i指向str1,j指向str2
            //需要考虑str1.charAt(i)!=str2.charAt(j),也是核心点,去调整j的大小
            while(j>0&&str1.charAt(i)!=str2.charAt(j)){
                j=next[j-1];
                //这个代码就是当碰到不相等的时候，然后它不停往前找，直到找到一个相等的
            }

            if(str1.charAt(i)==str2.charAt(j)){
                j++;
            }
            if(j==str2.length()){ //找到了 //j=3,i=2
                return i-j+1;
            }
        }
        return -1;
    }

    //获取到一个字符串（子串）的部分匹配值表
    public static int[] kmpNext(String dest){
        //创建一个next 数组保存部分匹配值
        int[] next=new int[dest.length()];
        next[0]=0;//如果字符串是长度为1 它的部分匹配值为0
        for (int i = 1,j=0; i <dest.length() ; i++) {
            //当dest.charAt(i)！=dest.charAt(j)时，我们需要从next[j-1]获取新的j
            //直到我们发现有dest.charAt(i)==dest.charAt(j)成立才退出
            //这是kmp算法的核心点
            while(j>0 && dest.charAt(i)!=dest.charAt(j)){
                j=next[j-1]; //回溯在这里
            }
            //当dest.charAt(i)==dest.charAt(j)条件满足时，部分匹配值+1
            if(dest.charAt(i)==dest.charAt(j)){
                j++;
            }
            next[i]=j;
        }
        return next;
    }
}
```



### 5. 贪心算法

> -> 是指在对问题进行求解时，**在每一步选择中都采取最好或者最优的选择，从而希望能够导致结果是最好或者最优的算法**
>
> **注**：贪婪算法得到的结果**不一定是最优结果（sometime是）**，但都是相对近似最优解的结果
>
> 
>
> **集合覆盖**问题：
>
> ​	假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。如何**选择最少的广播台**，让所有的地区都可以接收信号：
>
> | 广播台 |        覆盖区域        |
> | :----: | :--------------------: |
> |   K1   | ”北京“，”上海“，”天津“ |
> |   K2   | ”广州“，”北京“，”深圳“ |
> |   K3   | ”成都“，”上海“，“杭州” |
> |   K4   |     ”上海“，”天津“     |
> |   K5   |     “杭州”，“大连”     |
>
> 
>
> 可以：
>
> **穷举法** --> 列出每个可能的广播台的集合，也就是**“幂集”** （假设总有n个广播台 -> 则广播台的组合共有 2^n^ -1）(**但效率低!!!**)
>
> 
>
> 贪心算法思路分析：
>
> （1）遍历所有广播电台，找一个覆盖了最多**未覆盖的地区**的电台（可能包含一些已覆盖，但没关系）
>
> （2）将此电台加入到一个集合中（比如ArrayList）,想办法把该电台覆盖的地区在下次比较时去掉
>
> （3）重复第1步，直到完全覆盖



```java
package algorithm.greedy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class GreedyAlgorithm {
    public static void main(String[] args) {
        //创建广播电台，放入到Map
        HashMap<String, HashSet<String>> broadcasts = new HashMap<String, HashSet<String>>();
        //将各个电台放入到broadcasts
        HashSet<String> hashSet1 = new HashSet<>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");

        HashSet<String> hashSet2 = new HashSet<>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");

        HashSet<String> hashSet3 = new HashSet<>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("深圳");

        HashSet<String> hashSet4 = new HashSet<>();
        hashSet4.add("上海");
        hashSet4.add("天津");

        HashSet<String> hashSet5 = new HashSet<>();
        hashSet5.add("杭州");
        hashSet5.add("大连");
        //加入到map
        broadcasts.put("K1",hashSet1);
        broadcasts.put("K2",hashSet2);
        broadcasts.put("K3",hashSet3);
        broadcasts.put("K4",hashSet4);
        broadcasts.put("K5",hashSet5);

        //存放所有的地区
        HashSet<String> allAreas = new HashSet<>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("成都");
        allAreas.add("大连");

        //创建ArrayList,存放选择的电台集合
        ArrayList<String> selects = new ArrayList<>();

        //定义一个临时的集合，在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
        HashSet<String> tempSet = new HashSet<>();

        //定义一个maxKey，保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key
        //如果maxKey 不为null,则会加入到selects
        String maxKey=null;
        while(allAreas.size()!=0){ //如果allAreas不为0，则表示还没有覆盖到所有的地区
            //每进行一次while，需要
            maxKey=null;

            //遍历broadcasts，取出对应的key
            for (String key:broadcasts.keySet()) {
                //每进行一次for
                tempSet.clear();
                //当前这个key能够覆盖的地区
                HashSet<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
                //得到tempSet和allAreas集合的交集,交集会赋给这个tempSet
                tempSet.retainAll(allAreas);
                //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合未覆盖的地区还多
                //就需要重置maxKey
                //tempSet.size()>broadcasts.get(maxKey).size())体现处贪心算法的特点，每次都选最优的
                if(tempSet.size()>0 &&
                        (maxKey==null || tempSet.size()>broadcasts.get(maxKey).size())){
                    maxKey=key;
                }
            }
            //maxKey!=null,就应该将maxKey加入selects
            if(maxKey!=null){
                selects.add(maxKey);
                //将maxKey指向的广播电台覆盖的地区，从allAreas去掉
                allAreas.removeAll(broadcasts.get(maxKey));
            }
        }
        System.out.println("得到的选择结果是"+selects); //[K1, K2, K3, K5]
    }
}
```





### 6. 普利姆问题

> 应用场景-修路问题：
>
> （1）7个村庄：（A,B,C,D,E,F,G），现在需要修路把7个村庄连通
>
> （2）各个村庄的距离用边线表示（权），比如A-B距离5公里
>
> 问：如何修路保证各个存在都能连通，并且总的修建公里总里程最短
>
> 
>
> 思路：将10条边，连接即可，但总的里程数不是最小
>
> 正确思路：尽可能选择少的路线，并且每条路线最小，保证总里程数最小
>
> 其实这个问题的本质是**最小生成树MST** ( Minimum Cost Spanning Tree)

#### 最小生成树

> （1）给定一个带权的无向连通图，如何选取一棵生成树，使书上所有**边上权的总和为最小**
>
> （2）如果N个顶点，至少一定有N-1条边，（这样才能保证连通）包含全部顶点，N-1条边都在图中
>
> （3）求最小生成树，两种算法：**普利姆算法**和**克鲁斯卡尔算法**



prim算法介绍：

> => 也就是在包含n个顶点的连通图中，找出只有（n-1）条边包含所有n个顶点的连通子图=>**极小连通子图**
>
> 算法如下：
>
> （1）设G=(V,E)是连通网，T=(U,D)是最小生成树， V,U分别是顶点集合，E,D是边的集合
>
> （2）从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的 visited[u] =1
>
> （3）若集合U中顶点ui与集合V-U中顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1
>
> （4）重复步骤（2），直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边

```java
package algorithm.prim;

public class PrimAlgorithm {
    public static void main(String[] args) {
        //测试看看图是否创建成功
        char[] data=new char[]{'A','B','C','D','E','F','G'};
        int verxs=data.length;
        //邻接矩阵的关系使用二维数组表示
        //10000表示不连通，weight很大，永远选不到它嘛不是
        int[][] weight=new int[][]{
                {10000,5,7,10000,10000,10000,2},
                {5,10000,10000,9,10000,10000,3},
                {7,10000,10000,10000,8,10000,10000},
                {10000,9,10000,10000,10000,4,10000},
                {10000,10000,8,10000,10000,5,4},
                {10000,10000,10000,4,5,10000,6},
                {2,3,10000,10000,4,6,10000}
        };
        //创建MGraph对象
        MGraph graph = new MGraph(verxs);
        //创建一个MinTree对象
        MinTree minTree = new MinTree();
        minTree.createGraph(graph,verxs,data,weight);
        //输出
        minTree.showGraph(graph);
        //测试普利姆算法
        System.out.println("=================");
        minTree.prim(graph,0);
    }
}
//=================================================================================================================
package algorithm.prim;

public class MGraph {
    int verxs; //表示图的节点个数
    char[] data; //存放节点数据
    int[][] weight;  //存放边的权值，也就是我们的邻接矩阵

    public MGraph(int verts){
        this.verxs=verts;
        data=new char[verts];
        weight=new int[verts][verts];
    }
}
//=================================================================================================================
package algorithm.prim;

import java.util.Arrays;

//创建最小生成树->村庄的图
public class MinTree {
    //创建图的邻接矩阵

    /**
     *
     * @param graph 图对象
     * @param verxs 图对应的顶点个数
     * @param data 图的各个顶点的值
     * @param weight 图的邻接矩阵
     */
    public void createGraph(MGraph graph,int verxs,char data[],int[][] weight){
        int i,j;
        for (i = 0; i < verxs; i++) { //顶点
            graph.data[i] =data[i];
            for (j = 0; j < verxs; j++) {
                graph.weight[i][j]=weight[i][j];
            }
        }
    }

    //显示图的方法
    public void showGraph(MGraph graph){
        for (int[] link:graph.weight) {
            System.out.println(Arrays.toString(link));
        }
    }

    //编写prim算法，得到最小生成树
    /**
     *
     * @param graph 图
     * @param v 表示从图的第几个顶点开始生成'A' -> 0
     */
    public void prim(MGraph graph,int v){
        //visited[] 标记节点是否被访问过
        int[] visited = new int[graph.verxs];
        //visited 默认元素的值都是0,表示没有访问过
        //把当前这个给节点标记为已访问
        visited[v]=1;
        //用h1和h2记录两个顶点的下标
        int h1=-1;
        int h2=-1;
        int minWeight=10000; //将minWeight初始化成一个大数，后面在遍历过程中，会被替换
        for (int k = 1; k < graph.verxs; k++) {
            //因为有graph.verxs顶点，普利姆算法结束后，有graph.vertx-1边

            //这个是确定每一次生成的子图，和哪个节点的距离最近
            for (int i = 0; i < graph.verxs; i++) { //i节点表示被访问过的节点
                for (int j = 0; j < graph.verxs; j++) { //j表示还没有被访问的节点
                    if(visited[i]==1 && visited[j]==0 && graph.weight[i][j]<minWeight){
                        //替换minWeight（寻找已经访问过的节点和未访问过的节点间的权值最小的边）
                        minWeight=graph.weight[i][j];
                        h1=i;
                        h2=j;
                    }
                }
            }
            //找到一条边是最小的
            System.out.println("边<" + graph.data[h1]+","+graph.data[h2]+">权值："+minWeight);
            //将当前这个节点标记为已经访问
            visited[h2]=1;
            minWeight=10000;//重新设置为最大值
        }
```



### 7.克鲁斯卡尔算法

> 应用场景-公交站问题：
>
> （1）某城市新增7个站点（A,B,C,D,E,F,G），现在需要修路把7个站点连通
>
> （2）各个站点的距离用边线表示（权），比如A-B距离12公里
>
> 问：如何修路保证各个站点都能连通，并且总的修路公路总里程最短

Kruskal算法介绍：

> => 求加权连通图的最小生成树的算法
>
> （1）基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路
>
> （2）具体做法：构造一个只含n个顶点的森林，
>
> ​		a.排序：依权值从小到大中选择添加到森林中
>
> ​		b.加入：使森林中不产生回路（如何判断），直到森林变成一棵树
>
> ​		判断：就是去判断顶点到终点，终点为与它连通的最大顶点，其终点是否相同。加入的边的两个顶点不能都指向同一个终点，否则构成回路。

```java
package algorithm.kruskal;

import java.util.Arrays;

public class KruskalCase {
    private int edgeNum; //边的个数
    private char[] vertexs; //顶点数组
    private int[][] matrix; //邻接矩阵
    //使用INF 表示两个顶点不能连通
    private static final int INF=Integer.MAX_VALUE;


    public static void main(String[] args) {
        char[] vertexs={'A','B','C','D','E','F','G'};
        int[][] matrix={//0表示自己跟自己连接，INF表示不可连接
                {0,12,INF,INF,INF,16,14},
                {12,0,10,INF,INF,7,INF},
                {INF,10,0,3,5,6,INF},
                {INF,INF,3,0,4,INF,INF},
                {INF,INF,5,4,0,2,8},
                {16,7,6,INF,2,0,9},
                {14,INF,INF,INF,8,9,0}};
        //创建对象示例
        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);
        System.out.println("=====================");
        //输出构建是否正确
        kruskalCase.print();
//        EData[] edges = kruskalCase.getEdges();
//        System.out.println("排序前="+ Arrays.toString(edges));//没有排序
//        kruskalCase.sortEdge(edges);
//        System.out.println(("排序后=" + Arrays.toString(edges)));
        kruskalCase.kruskal();
    }

    //构造器
    public KruskalCase(char[] vertexs, int[][] matrix){
        //初始化顶点数和边的个数
        int vlen=vertexs.length;
        //初始化顶点,复制拷贝的方式
        this.vertexs=new char[vlen];
        for (int i = 0; i < vertexs.length; i++) {
            this.vertexs[i] =vertexs[i];
        }
        //初始化边，使用的是复制拷贝的方式
        this.matrix=new int[vlen][vlen];
        for (int i = 0; i < vlen; i++) {
            for (int j = 0; j < vlen; j++) {
                this.matrix[i][j]=matrix[i][j];
            }
        }
        //统计边
        for (int i = 0; i < vlen; i++) {
            for (int j = i+1; j < vlen; j++) {
                if(this.matrix[i][j]!=INF){
                    edgeNum++;
                }
            }
        }
    }
    public void kruskal(){
        int index=0; //表示最后结果数组的索引
        int[] ends=new int[edgeNum]; //用于保存“已有最小生成树”中的每个顶点在最小生成树中的终点
        //创建结果数组，保存最后的最小生成树
        EData[] rets=new EData[edgeNum];

        //获取图中所有的边的集合，一共有12条边
        EData[] edges=getEdges();
        System.out.println("获取图的边的集合="+Arrays.toString(edges)+"共"+edges.length); //12
        //按照边的权值大小进行排序（从小到大）
        sortEdge(edges);

        //遍历edges数组，将边添加到最小生成树中，判断是准备加入的边是否形成了回路，如果没有，就加入rets，否则不能加入
        for (int i = 0; i < edgeNum; i++) {
            //获取到第i条边的第一个顶点
            int p1 = getPosition(edges[i].start);
            //获取到第i条边的第2个顶点
            int p2 = getPosition(edges[i].end);
            //获取p1这个顶点在我们已有最小生成树中的终点
            int m=getEnd(ends,p1);
            //获取p2这个顶点在我们已有最小生成树中的终点
            int n=getEnd(ends,p2);
            //判断是否构成回路
            if(m!=n){ //说明没有构成回路
                ends[m]=n; //设置m在“已有最小生成树”中的终点<E,F> [0,0,0,0,5,0,0,0,0,0,0,0]
                rets[index++]=edges[i]; //有一条边加入到rets数组
            }
        }
        //统计并打印“最小生成树”，输出rets数组
        System.out.println("最小生成树为=");
        for (int i = 0; i < index; i++) {
            System.out.println(rets[i]);
        }
    }

    //打印邻接矩阵
    public void print(){
        System.out.println("邻接矩阵为：\n");
        for (int i = 0; i < vertexs.length; i++) {
            for (int j = 0; j < vertexs.length; j++) {
                System.out.printf("%12d",matrix[i][j]);
            }
            System.out.println();
        }
    }

    // 对边进行排序处理，冒泡排序

    /**
     * 功能：对边进行排序（冒泡）
     * @param edges 边的集合
     */
    private void sortEdge(EData[] edges){
        for (int i = 0; i < edges.length; i++) {
            for (int j = 0; j < edges.length-1; j++) {
                if(edges[j].weight>edges[j+1].weight){ //交换
                    EData tmp=edges[j];
                    edges[j]=edges[j+1];
                    edges[j+1]=tmp;
                }
            }
        }
    }

    /**
     *
     * @param ch 顶点的值，比如'A','B'
     * @return 返回ch顶点对应的下标，如果找不到，返回-1
     */
    private int getPosition(char ch){
        for (int i = 0; i < vertexs.length; i++) {
            if(vertexs[i]==ch){//找到
                return i;
            }
        }
        //如果找不到，返回-1
        return -1;
    }

    /**
     * 功能：获取图中边，放到EData[]数组中，后面我们需要遍历该数组
     * 是通过matrix 邻接矩阵来得到
     * EData[['A','B',12],['B','F',7],....]
     * @return
     */
    private EData[] getEdges(){
        int index=0;
        EData[] edges = new EData[edgeNum];
        for (int i = 0; i < vertexs.length; i++) {
            for (int j = i+1; j < vertexs.length; j++) {
                if(matrix[i][j]!=INF){
                    edges[index++]=new EData(vertexs[i],vertexs[j],matrix[i][j]);
                }
            }
        }
        return edges;
    }

    /**
     * 功能：获取下标为i的顶点的终点，用于后面判断两个顶点的终点是否相同
     * @param ends :数组就是记录了各个顶点对应的终点是哪个，ends数组是在遍历过程中，逐步形成的
     * @param i ：传入的顶点对应的下标
     * @return 返回的就是下标为i的这个顶点对应的终点的下标
     */
    private int getEnd(int[] ends,int i){ //i=5,[0,0,0,0,5,0,0,0,0,0,0,0]
        while(ends[i]!=0){
            i=ends[i];
        }
        return i;
    }
}
//=================================================================================================================
package algorithm.kruskal;

//创建一个类EData,它的对象实例就表示一条边
public class EData {
    char start; //边的起点（一个点）
    char end; //边的终点（另外一个点）
    int weight; //边的权值
    public EData(char start,char end, int weight){
        this.start=start;
        this.end=end;
        this.weight=weight;
    }

    //重写toString方法，便于输出边
    @Override
    public String toString() {
        return "EData{<" +
                 start +
                ", " + end +
                ">=" + weight +
                '}';
    }
}
```



### 8.迪杰斯特拉算法

> 应用场景-最短路径问题：
>
> （1）7个村庄（A,B,C,D,E,F,G）,现在6个邮差，从G点出发，分别把邮件送往A,B,C,D,E,F六个村庄
>
> （2）各个村庄的距离用边线表示（权），比如A-B距离5公里
>
> 问：计算出G村庄到其他各个村庄的最短距离?如果从其他点出发到各个点的距离又是多少？

Dijkstra算法介绍:

> 典型最短路径算法：用于计算一个节点到其他节点的最短路径。
>
> 主要特点：以起始点为中心向外层扩展（广度优先BFS搜索思想），直到终点为止。
>
> 
>
> 算法过程：
>
> 设置出发顶点v，顶点集合V{v1,v2,..vi}，然后v到V各个顶点的距离构成距离集合Dis{d1,d2,...di},
>
> （1）从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时v到vi即为最短路径
>
> （2）更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个（同时也应该更新前驱节点vi）
>
> （3）重复执行两步骤，直到最短路径顶点为目标顶点即可结束
