# 关于集合竞价因子挖掘



> 集合竞价规则，集合竞价从915至925，915至920 可挂单可撤单，920至92459可挂单不可撤单。925 遵循成交量最大原则，撮合成交价。925至930：可挂单也可撤单，但委托单不进入交易系统，而是等到930连续竞价开始时才会被处理。

因子目的：用于集合竞价成交时计算，因此在925时撮合成交时必须计算出来，因此因子计算数据只能到<92459950

## 尝试一

(1) 用915到92459950（< 92459950），取集合成交前50毫秒的数据（最后一行数据），把这一行当作集合成交价格，取当前撮合价格当作**目标价格**，取这一行的**当前撮合成交量**，后面会用到。

> ApplSeqNum  tradetime  Price  ...  该订单下单后的买一价     TICKER      DATE
> 5179      247848   92459900  17.04  ...       16.39  000001.SZ  20220128

（2) 分割最后一行数据，得到下面数据，用下面数据选定 side==1且当行Price> **目标价格**，price的限定条件是说肯定能撮合成交。将满足条件的行选出来，用成交的量减去撤单的量，求和。用这个和 / **当前撮合成交量** 得到因子。

> ApplSeqNum  tradetime  Price  ...  该订单下单后的买一价     TICKER      DATE
> 0            106   91500000  16.30  ...       16.30  000001.SZ  20220128
> 1            112   91500000  16.30  ...       16.30  000001.SZ  20220128
> 2            183   91500000  16.30  ...       16.30  000001.SZ  20220128
> 3            377   91500020  17.60  ...       16.30  000001.SZ  20220128
> 4            381   91500020  17.93  ...       16.30  000001.SZ  20220128
> ...          ...        ...    ...  ...         ...        ...       ...
> 5175      244666   92458220  16.82  ...       16.38  000001.SZ  20220128
> 5176      246783   92459270  16.55  ...       16.39  000001.SZ  20220128
> 5177      247137   92459430  16.33  ...       16.39  000001.SZ  20220128
> 5178      247472   92459660  16.55  ...       16.39  000001.SZ  20220128

这个因子的意义，应该是算主动流入量/ 最终撮合成交量的比值，但没什么效果。

```python
dt = feather.read_dataframe(os.path.join(self.df_path, f'{date}.feather'))
# 首先，前五分钟拿出来
# 排序选前面行，排除最后一行
dt = dt[dt['tradetime'] < 92459950].reset_index(drop=True)
end_dt = dt.groupby('TICKER').tail(1)
dt = dt[(dt['tradetime'] < 92000000)].reset_index(drop=True)
# 你要去找到前五分钟的流入
# dt['active_flow_dir']=np.where(dt['Side']=='1',1,np.where(dt['Side']=='2',-1,np.nan))
# 1代表主动流入，-1代表主动流出
# dt['amount'] = dt['Price'] * dt['TradeQty']
# dt['active_netflow_money'] = dt['amount'] * dt['active_flow_dir']
# dt['active_netflow_qty'] = dt['TradeQty']
dt.sort_values(['TICKER','ApplSeqNum'],inplace=True)
# 选定最后一行价格为撮合价格
the_price=end_dt[['TICKER','当前撮合价格']].rename(columns={'当前撮合价格':'the_price'})
dt=dt.merge(the_price,on='TICKER',how='left')
tt1=dt[(dt['Side']=='1')&(dt['Price']>dt['the_price'])]
tt1=tt1.groupby(['TICKER','type'])['TradeQty'].sum().reset_index()
tt1=pd.pivot(tt1, columns='type', index='TICKER', values='TravdeQty')
tt1.replace(np.nan,0,inplace=True)
tt1['inflow']=tt1['A']-tt1['4']
tt1=tt1[['inflow']]
res=tt1.merge(end_dt[['TICKER','当前撮合成交量']],how='inner',on='TICKER')
res['tt']=res['inflow']/res['当前撮合成交量']
res['DATE'] = date
res=res[['DATE','TICKER','tt']]
```



## 尝试二（成功） => auc_factor1.py

因为之前 主动净流入额 这个因子效果不错，可用

```python
dt['active_flow_dir']=np.where((dt['Side']=='1')&(dt['当前撮合价格']>dt['上一笔撮合价格']),1,
 					np.where((dt['Side']=='2')&(dt['当前撮合价格']<dt['上一笔撮合价格']),-1,np.nan))# 1代表主动流入，-1代表主动流出
dt['amount'] = dt['Price'] * dt['TradeQty']
dt['active_netflow_money']=dt['amount']*dt['active_flow_dir']
# 下面这个因子效果不错
dt.groupby('TICKER')['主动净流入额'].mean()
```



另一个尝试

猜测它有效的原因主要在于主动流入的信息上，所以只选出了'active_flow_dir'值有效的行，删除此列为 nan 的行，因为觉得主动流动包含信息比较多，其他未必能成交，属于无用信息，作了以下尝试

```python
dt['total_amt']=dt['小单amt']+dt['中单amt']+dt['大单amt']
dt['total_笔数']=dt['小单笔数']+dt['中单笔数']+dt['大单笔数']
res3=dt.groupby('TICKER').agg({'小单amt':'sum','中单amt':'sum','大单amt':'sum','小单笔数':'sum','中单笔数':'sum','大单笔数':'sum','total_amt':'sum','total_笔数':'sum'})

res1=dt.groupby('TICKER')['active_flow_dir'].count()/dt.groupby('TICKER')['DATE'].count()

res2=dt[dt['active_flow_dir']==1].groupby('TICKER'['active_flow_dir'].count()/dt[dt['active_flow_dir']==-1].groupby('TICKER')['active_flow_dir'].count()

res3=dt.groupby('TICKER').agg({'小单amt':'sum','中单amt':'sum','大单amt':'sum','小单笔数':'sum','中单笔数':'sum','大单笔数':'sum','total_amt':'sum','total_笔数':'sum'})
for c in ['小单','中单','大单']:
        res3[c+'amt_ratio']=res3[c+'amt']/res3['total_amt']
        res3[c+'笔数_ratio']=res3[c+'笔数']/res3['total_笔数'] 
```

结果效果都不行。。。

## 尝试三 (成功）=> auc_factor1.py

因为考虑到920之前是允许撤单的，因此920之前maybe有很多数据泡沫。选定撮合成交前10s（60s），因为认为在此时，整个盘面信息已经基本确定，这时候下单最有可能达成目的同时也可能是大单的真实目的，因此做以下运算。

同时，用数据里最后5s的close,作为尾盘价，跟昨天的close，算个收益测测看。

```python
# 用最后一刻的close,作为尾盘价，跟昨天的close，计算个收益
end_dt=dt.groupby('TICKER').tail(1)[['TICKER','close']]
trade10=dt.groupby('TICKER').tail(2)
trade60=dt.groupby('TICKER').tail(12)

res1=trade10.groupby('TICKER').agg({'主动净流入额':['mean','std'],'主动净流入量':['mean','std'],'大单amt':['mean','std'],'大单笔数':['mean','std']})
res1.columns=['最后10s'+col[0]+'_'+col[1] for col in res1.columns]
res2=trade60.groupby('TICKER').agg({'主动净流入额':['mean','std'],'主动净流入量':['mean','std'],'大单amt':['mean','std'],'大单笔数':['mean','std']})
res2.columns=['最后60s'+col[0]+'_'+col[1] for col in res2.columns]
               res=res1.merge(res2,right_index=True,left_index=True,how='inner').reset_index().merge(end_dt,on='TICKER',how='inner')
# ---------------------------------------
alls=alls.merge(self.daily_df,on=['TICKER','DATE'],how='left')
alls['ret']=alls['close']/alls['pre_close']-1
alls.drop(columns=['close','pre_close'],inplace=True)
```



其中，**auc_最后10s主动净流入量__mean** ，**auc最后10s主动净流入量std**，**auc_最后60s主动净流入量mean**，**auc_最后60s主动净流入量__std**数据最为有效，多头占到了千2水平。



## 尝试四(成功) => auc_factor2.py

买卖分开，集合竞价期间接受的某个方向的委托在开盘前撮合时成交得越多，说明市场对这个方向的成交意愿越强烈，推动股价朝这个方向发展。

时间段：第一时段09.15.00.000-09.19.59.999、第二时段09.20.00.000-09.24.59.999

方向：买、卖

（以第一时段买方为例）：对某日某个股，该因子为两项之比，分子为在09.25.00.000集合竞价撮合时买方的撮合成交量（与卖方相等）；分母为第一时段内买方累计委托总量（包括撤单，换言之即使过后撤单也要计入对应量）。交叉组合共计四个因子。

```python
dt = feather.read_dataframe(os.path.join(self.df_path, f'{date}.feather'))
# dt = dt[(dt['tradetime'] >= 92000000) & (dt['tradetime'] < 92459950)].reset_index(drop=True)
dt = dt[dt['tradetime'] < 92459950].reset_index(drop=True)
dt.sort_values(['TICKER','ApplSeqNum'],inplace=True)
end_dt=dt.groupby('TICKER').tail(1)[['TICKER','当前撮合成交量']].set_index('TICKER')
dt=dt.groupby('TICKER',as_index=False).apply(lambda x:x.head(-1)).reset_index(drop=True)
dt1=dt[dt['tradetime']< 91959999]
dt1['TradeQty']=np.where(dt1['type']=='4',-1*dt1['TradeQty'],dt1['TradeQty'])
dt2=dt[dt['tradetime']>=92000000]
# ------------------------------
time1_buy=dt1[dt1['Side']=='1'].groupby('TICKER').agg({'TradeQty':'sum'}).rename(columns={'TradeQty':'time1_buyQty'})
time1_sell=dt1[dt1['Side']=='2'].groupby('TICKER').agg({'TradeQty':'sum'}).rename(columns={'TradeQty':'time1_sellQty'})
time2_buy=dt2[dt2['Side']=='1'].groupby('TICKER').agg({'TradeQty':'sum'}).rename(columns={'TradeQty':'time2_buyQty'})
time2_sell=dt2[dt2['Side']=='2'].groupby('TICKER').agg({'TradeQty':'sum'}).rename(columns={'TradeQty':'time2_sellQty'})
res=end_dt.merge(time1_buy,right_index=True,left_index=True,how='inner').merge(time1_sell,right_index=True,
    left_index=True,how='inner').merge(time2_buy,right_index=True,left_index=True,how='inner').merge(time2_sell,
    right_index=True,left_index=True,how='inner')
tar_col=np.setdiff1d(res.columns,['当前撮合成交量'])
for col in tar_col:
    res[col+'_tradeQty']=res['当前撮合成交量']/res[col]
res=res[[col+'_tradeQty' for col in tar_col]].reset_index()
```



## 拓展得到的有效因子：(成功) => auc_sell_buy_qty.py 和 auc_sell_to_buy.py

```python
dt = feather.read_dataframe(os.path.join(self.df_path, f'{date}.feather'))
# dt = dt[(dt['tradetime'] >= 92000000) & (dt['tradetime'] < 92459950)].reset_index(drop=True)
dt = dt[dt['tradetime'] < 92459950].reset_index(drop=True)
dt.sort_values(['TICKER','ApplSeqNum'],inplace=True)
# dt['TradeQty'] = np.where(dt['type'] == '4', -1 * dt['TradeQty'], dt['TradeQty'])
end_dt = dt.groupby('TICKER').tail(1)[['TICKER','当前撮合成交量']].set_index('TICKER')
# end_dt['撮合成交额']=end_dt['当前撮合价格']*end_dt['当前撮合成交量']
# end_dt=end_dt[['撮合成交额']]
dt = dt.groupby('TICKER', as_index=False).apply(lambda x: x.head(-1)).reset_index(drop=True)
# dt['amount']=dt['Price']*dt['TradeQty']
dt2=dt[dt['tradetime']>=92000000]
dt3=dt[dt['tradetime']>=92454000]
# ============================================================
tt2 = dt2[dt2['Side'] == '2']
# 因子一：用主动成交-被动成交，跟原因子ic相反
tt2['tt']=np.where(tt2['上一笔撮合价格']>tt2['当前撮合成交量'],1,-1)
tt2['TradeQty']*=tt2['tt']
time2_sell=tt2.groupby('TICKER').agg({'TradeQty':'sum'}).rename(columns={'TradeQty':'time2_sellQty'})
res1=end_dt.merge(time2_sell,right_index=True,left_index=True,how='inner')
tar_col=np.setdiff1d(res1.columns,['当前撮合成交量'])
for col in tar_col:
    res1[col+'_Act_tradeQty']=res1['当前撮合成交量']/res1[col]
res1 = res1[[col + '_Act_tradeQty' for col in tar_col]]#.reset_index()
# ============================================================
# 因子二：用原因子里的sell方-buy方
time2_buy = dt2[dt2['Side'] == '1'].groupby('TICKER').agg({'TradeQty': 'sum'}).rename(columns={'TradeQty': 'time2_buyQty'})
time2_sell = dt2[dt2['Side'] == '2'].groupby('TICKER').agg({'TradeQty': 'sum'}).rename(columns={'TradeQty': 'time2_sellQty'})
res2=time2_buy.merge(time2_sell, right_index=True,left_index=True, how='outer')
res2.replace(np.nan,0,inplace=True)
res2['NetSellQty']=res2['time2_sellQty']-res2['time2_buyQty']
res2=res2[['NetSellQty']]#.reset_index()
# ============================================================
# 因子三：用原因子里的sell方-buy方，时间锁定在差不多最后撮合成交5s内
time3_buy = dt3[dt3['Side'] == '1'].groupby('TICKER').agg({'TradeQty': 'sum'}).rename(columns={'TradeQty': 'time3_buyQty'})
time3_sell = dt3[dt3['Side'] == '2'].groupby('TICKER').agg({'TradeQty': 'sum'}).rename(columns={'TradeQty': 'time3_sellQty'})
res3 = time3_buy.merge(time3_sell, right_index=True, left_index=True, how='outer')
res3.replace(np.nan, 0, inplace=True)
res3['NetSellQty_last5s'] = res3['time3_sellQty'] - res3['time3_buyQty']
res3 = res3[['NetSellQty_last5s']]#.reset_index()
res=res1.merge(res2,right_index=True,left_index=True,how='outer').merge(res3,right_index=True,left_index=True,how='outer')
res.reset_index(inplace=True)
# ==========================================================
# 因子四：用原因子里的sell方/buy方
time2_buy = dt2[dt2['Side'] == '1'].groupby('TICKER').agg({'TradeQty': 'sum'}).rename(columns={'TradeQty': 'time2_buyQty'})
time2_sell = dt2[dt2['Side'] == '2'].groupby('TICKER').agg({'TradeQty': 'sum'}).rename(columns={'TradeQty': 'time2_sellQty'})
res2=time2_buy.merge(time2_sell, right_index=True,left_index=True, how='outer')
res2.replace(np.nan,0,inplace=True)
res2['NetSellQty']=res2['time2_sellQty']/res2['time2_buyQty']
res2=res2[['NetSellQty']]#.reset_index()
time3_buy = dt3[dt3['Side'] == '1'].groupby('TICKER').agg({'TradeQty': 'sum'}).rename(columns={'TradeQty': 'time3_buyQty'})
time3_sell = dt3[dt3['Side'] == '2'].groupby('TICKER').agg({'TradeQty': 'sum'}).rename(columns={'TradeQty': 'time3_sellQty'})
res3 = time3_buy.merge(time3_sell, right_index=True, left_index=True, how='outer')
# res3.replace(np.nan, 0, inplace=True)
res3['NetSellQty_last5s'] = res3['time3_sellQty']/res3['time3_buyQty']
res3 = res3[['NetSellQty_last5s']]#.reset_index()
```



some idea could try ... ...

> 集合竞价回溯20天，选取价格最高/最低的4天，计算平均换手率，跟20天平均换手率做比较；同时还有当天收益率。背后逻辑是 高位放量，低位波动。

